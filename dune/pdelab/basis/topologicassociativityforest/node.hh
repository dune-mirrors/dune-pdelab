#ifndef DUNE_PDELAB_BASIS_ORDERING_TOPOLOGIC_ASSOCIATIVITY_FOREST_NODE_HH
#define DUNE_PDELAB_BASIS_ORDERING_TOPOLOGIC_ASSOCIATIVITY_FOREST_NODE_HH

#include <dune/pdelab/common/multiindex.hh>
#include <dune/pdelab/common/tree_traversal.hh>

#include <dune/pdelab/concepts/multiindex.hh>
#include <dune/pdelab/concepts/treenode.hh>

#include <dune/grid/concepts/entity.hh>

#include <dune/typetree/treepath.hh>
#include <dune/typetree/childextraction.hh>

#include <dune/localfunctions/common/interfaceswitch.hh>
#include <dune/localfunctions/common/localkey.hh>

#include <dune/geometry/type.hh>
#include <dune/geometry/typeindex.hh>
#include <dune/geometry/referenceelements.hh>

#include <vector>
#include <ranges>
#include <numeric>

namespace Dune::PDELab::Impl {

/**
 * @brief Ordering of entity degrees of freedom
 * This class is in charge to map a degree of freedom within an entity to a
 * multi-index. Such mapping is injective with respect to a specific entity,
 * in particular, the resulting multi-indices start from 0. For example, an
 * entity with 3 degrees of freedom may be mapped into (0), (1), and (2),
 * or into (0,0), (1,0), and (1,1) for a ordering of two children and blocked
 * structure.
 *
 * The mapping is constructed in a bottom-up fashion.
 * First, the leaf node extract an ordering based on a local finite element
 * for each entity (see LocalCoefficients and LocalKey objects from
 * dune-localfunctions). The resulting ordering for leaf nodes is guarnteed to
 * be consequitive with 0-based indexation, i.e. an entity that has 3 DOFs
 * associated with it, will alywas map their local keys into (0), (1) and (2).
 * This requirement is important in order to provide fast mappings for DG
 * spaces! Second, a parent node compose its children indices with respect to a
 * merging strategy. For example, a blocked strategy consists on prefixing the
 * child index into the child indices.
 *
 * In particular, the complexity on the implementation of this object comes
 * from the fact that the offsets for every entity in an entity set are stored
 * as contiguously as possible and using many information at compile time
 * whenever possible.
 *
 * The most important part to understand on this class are the
 * `firstContainerIndex` and `containerSize` methods. See their documentation
 * first. All the rest of this class turns around the data structures used in
 * there.
 *
 * This local map is the used to construct a global map that takes into account the
 * whole grid, in other words, a set of maps where each entity maps to a uniquely
 * different multi-index (which is the countrary of this class where each
 * entity is individually mapped and the result is not necessarily unique)
 * @see EntitySetOrderingNode.
 *
 * The mappings produced by this class is almost dense. The cases where the
 * map is not dense is where blocked structure induces a multi-index whose
 * suffix has a 0-size range on the last index. This happens when there is at
 * least one blocking merging strategy within the tree and the finite elements
 * of the different leaf nodes cover different codimensions. An example of
 * this case is taylorhood elements of degree 1 where all nodes are entity
 * ordered with blocked merged strategy: The root node will provide the whole
 * tree suffix to the multi-index (because of the blocked strategy) but the
 * children node corresponding to the pressure element have no DOFs in the
 * facets of the elements.
 *
 * @note Order of multi-indices: The indices generated by this map follow a
 * top to bottom ordering, meanig that lefttmost indices indicate a tree-path
 * from the upper part of a tree of indices, while rightmost indices indicate
 * lower parts on the tree. This is consistent with dune-functions and countrary
 * to PDELab orderings.
 *
 * @todo Compile-time check whether dense ordering is guaranteed
 * @todo Avoid repeated update on vector spaces_gt_dof_offsets
 * @todo Create an abrstraction for the offset vectors. Raw managment of them
 * has proven to be error prone and hard to mantain.
 *
 * @tparam Node   A typetree node using that inherits this class (Barton–Nackman trick)
 * @tparam MS     A merging strategy
 */
template<class Node, class MS>
class TopologicAssociativityForestNode
{
  // Notice that by this point `Node` is an incomplete type because it will only
  // be completed after inheriting from this class (Barton–Nackman trick)
  // Therefore, we can only inquiry its contents after completion, which
  // is why we only deduce types on functions and not in the class scope.

  // the type of the merging strategy
  using MergingStrategy = MS;
protected:
  // the type to export multi-indices
  using SizeType = typename MergingStrategy::EntitySet::IndexSet::IndexType;
private:
  // the type for entitysets
  using EntitySet = typename MergingStrategy::EntitySet;
  // the type for bitset information of codimensions used
  using CodimFlag = std::bitset<EntitySet::dimensionworld+1>;
  // a key value to identify geometry types that are not mapped by this class
  static constexpr SizeType GT_UNUSED = std::numeric_limits<SizeType>::max();

  // We share private methods with other nodes of the same kind. This allows
  // to have tree algorithms in one templated class and still keep internals
  // encapsulated to the outside.
  // But with great power comes great responsability:
  //   DO NOT MODIFY OTHER NODE PRIVATE MEMBERS!
  //   Otherwise code becomes -more- unmaintainable and harder to reason about
  //   instead create a function that describes the performed action
  template<class Node_, class MS_>
  friend class TopologicAssociativityForestNode;

public:

  TopologicAssociativityForestNode(const MergingStrategy& merging_strategy, bool power_node = false);

  TopologicAssociativityForestNode(const TopologicAssociativityForestNode&) = delete;
  TopologicAssociativityForestNode(TopologicAssociativityForestNode&&) = default;

  TopologicAssociativityForestNode& operator=(const TopologicAssociativityForestNode&) = delete;
  TopologicAssociativityForestNode& operator=(TopologicAssociativityForestNode&&) = default;

  // Gives the maximum size of a prefix produced by this ordering
  [[nodiscard]] static constexpr std::size_t maxContainerDepth();

  // Check if all leaf nodes have the same fixed DOF size per geometry type at compile time
  [[nodiscard]] static constexpr auto prioryFixedSize();

  // Check if this ordering has fixed DOF size per geometry type
  [[nodiscard]] auto fixedSize() const noexcept;

  // Entity set of the ordering
  [[nodiscard]] const auto& entitySet() const noexcept;

  // Entity set of the ordering
  [[nodiscard]] auto& entitySet() noexcept;

  // Check if a given geometry type is mapped to multi-indices within this map
  [[nodiscard]] bool containsGeometry(SizeType gt_index) const noexcept;

  // Check if a given geometry type is mapped to multi-indices within this map
  [[nodiscard]] bool containsGeometry(const GeometryType& gt) const noexcept;

  // Check if a given codimension is mapped to multi-indices within this map
  [[nodiscard]] bool containsCodim(SizeType codim) const noexcept;

  // Gives a bitset of the codimenions that this class is able to map
  [[nodiscard]] CodimFlag codimClosure() const noexcept;

  // Check if DOFs only exist in one codimension
  //! @note This feature is really important. If true, all the multi-indices
  // can be constructed from the container index suffix and the block count of
  // a given tree (i.e. no need of local keys of the reference local element).
  [[nodiscard]] auto singleCodim() const noexcept;

  // Check if DOFs are only attached to the volume part of the entities.
  // If true, it should hint to DG and FV spaces.
  [[nodiscard]] auto disjointCodimClosure() const noexcept;

  // Maximum number of coefficients that may be associated to a local space
  [[nodiscard]] SizeType maxLocalCount() const noexcept;

  // print offsets to debug orderings...
  // TODO implement other nodes other than leaf...
  void debugInfo() const;


  // counts the number of blocks in the leaf nodes
  [[nodiscard]] SizeType dimension() const noexcept;

  /**
   * @brief Gives a container prefix (Outer2Inner) for a particular entity and leaf node of the
   * tree. The resulting multi-index suffix contains the mapping for the first
   * DOF on the leaf node and entity. Due to the guarantees of this class,
   * this is enough information to form all of the other DOFs associated for
   * this entity. In particular, is only necessary to accumulate front the
   * local key of the finite element in order to obtain a desired container
   * index.
   * @note If disjointCodimClosure() is true, the whole range of indices for
   * this entity may be obtained by accumulating back in range of
   * [ 0, child(comp_suff).blockCount(gt_index, entity_index) ).
   *
   * @tparam CompositionSuffix      Type for a treepath (typicaly MultiIndex)
   * @param comp_suff               Path to the required leaf node
   * @param gt_index                Index of the geometry type
   * @param entity_index            Index of the entity
   * @return Concept::MultiIndex    A Outer2Inner prefix to the first container multi-index
   */

  // note that is different node().child(path).containerIndexRange(...) than node().containerIndexRange(path,...)
  template<Concept::MultiIndex CompositionSuffix>
  [[nodiscard]] auto containerIndexRange(
    CompositionSuffix comp_suff,
    SizeType gt_index,
    SizeType entity_index) const noexcept;

  // Check if the resulting container is blocked at this node level
  [[nodiscard]] static constexpr auto containerBlocked();

  /**
   * @brief Gives the total number of indices for any suffix of the mapped
   * multi-indices
   * @details Any suffix of a container index generated by this object
   * (constructed from `firstContainerIndex`) indices a size. Such size refers
   * to the range of suffixes on the next level of multi-indices. For example,
   * if a node tree is able to generate the following Inner2Outer multi-indices
   * for a given entity (0,0,0), (0,1,0), ..., (0,10,0), then the suffix (-,-,0)
   * induces a size of 11 while (-,0,0), (-,1,0), etc. induce all a size of 1.
   *
   * @tparam ContainerSuffix  The type of a sufix (typically a PDELab::MultiIndex)
   * @param cs                A suffix of a Outer2Inner multi-index contained by this map
   * @param gt_index          Index of the geometry type
   * @param entity_index      Index of the entity
   * @return std::size_t      The size induced by the multi-index suffix
   */
  template<Concept::MultiIndex ContainerSuffix>
  [[nodiscard]] std::size_t containerSize(const ContainerSuffix& cs,
                                          SizeType gt_index,
                                          SizeType entity_index) const noexcept;

  void update(EntitySet entity_set);

  // this method needs be called only on the root node of the local space
  // tree the fixed and variable size updates propagate their calls down the
  // tree. In particular, this produces a depth first algorithm. Before every
  // node: Allocate and set-up node. Before/After children: Carry partial
  // calculation of the children sizes After every node: Calculate final sizes
  // of children and accumulate to obtain offets.
  void update();

  // Number of blocks associated to a given entity
  [[nodiscard]] auto blockCount(const SizeType gt_index,
                                const SizeType entity_index) const noexcept;

  // number of blocks associated to a given entity (fixed size version)
  [[nodiscard]] auto blockCount(std::size_t gt_index) const noexcept;

  // total number of blocks for this node on all entities
  [[nodiscard]] auto blockCount() const noexcept;

private:

  // A priory compile-time information if a given codimension may contain DOFs wrt a grid entity
  // If false, there is a guarantee that this map will never contain such a
  // codimension. If true, codimension may or may not be used at run-time
  template<class EntityCodim>
  [[nodiscard]] static constexpr auto mayContainCodim(EntityCodim entity_codim);

  //! Compile-time information of maximum codimensions used by this map
  //! @note Notice that less codimenions may be actually used at run-time
  [[nodiscard]] static auto constexpr maxCodimCount();

  //! Setup ordering for fixed size maps
  //! @note Recursive function, only call this from root node.
  void updateFixedSizeOrderings();

  //! Pre-allocate objects on this node related to the variable size ordering
  void allocateVariableSizeOrdering();

  //! Collect used geometry types on leaf nodes (variable size)
  template<class Entity>
  void collectLeafGeometryTypes(const Entity& entity);

  //! Collect geometry types for all nodes (variable size)
  //! @note Use after every leaf node called `collectLeafGeometryTypes`
  //! @note Recursive function, only call this from root node.
  void collectGeometryTypes();

  //! Gather sizes for entity sizes on the leaf node from local keys (variable
  //! size)
  //! @note Use this after geometry types have been collected
  //! @note This class additionally checks if sizes change between different
  //! entities, thus, allowing us to know if we can compress variable size data
  //! into fixed size data
  template<class Entity>
  void collectEntitySizes(const Entity& entity, std::vector<SizeType>& gt_cache);

  //! Convert size vectors into offset vectors
  //! This class first identifies if fixed size is possible, then accumulate
  //! offsets in the corresponding data structure
  //! @note Recursive function, only call this from root node.
  void accumulateEntityOffsets();

  //! Setup ordering for variable size maps
  //! @note Recursive function, only call this from root node.
  void updateVariableSizeOrderings();

private:
  //! Cast to node implementation (Barton–Nackman trick)
  const Node& node() const noexcept { return static_cast<const Node&>(*this); }
  Node& node() noexcept { return static_cast<Node&>(*this); }

  CodimFlag _codim_used;
  std::vector<bool> _gt_used;
  MergingStrategy _merging_strategy;
  std::size_t _max_local_coeff_count, _block_count;
  bool _fixed_size, _fixed_size_possible;

  /**
   *  Data for this node may be stored in fixed or variable size form:
   *
   * * Fixed Size:
   *    In this case, all entities of a given geometry type look the same.
   *    Thus, we just need to store the offset between nodes for each geometry
   *    type.
   *
   *    gt_index        ||    cell   || ... ||   vertex  || ... ||
   *    child_index     || 0 | 1 | 2 || ... || 0 | 1 | 2 || ... ||
   *    _gt_dof_offsets || 2 | 3 | 8 || ... || 1 | 2 | 3 || ... ||
   *
   * * Variable Size:
   *    In this case, every entity has potentially different sizes so we have
   *    to store each offset individully. This information is stored in the
   *    `_entity_dof_offsets`. Since grids have a different indexation for
   *    each geometry type, we store an offset for these geometry types in
   *    `_gt_entity_offsets`. This works similarly as the
   *    MultipleCodimMultipleGeomTypeMapper object in dune-grid works. This
   *    allows us to keep everything as packed and cache friendly as possible.
   *
   *    gt_index              || cell                          || vertex    ||
   *    _gt_entity_offsets    || *                             || *         ||
   *                             |                                |
   *                             v                                v
   *    entity_index          ||   cell0   ||   cell1   || ... ||  vertex0  ||
   *    child_index           || 0 | 1 | 2 || 0 | 1 | 2 || ... || 0 | 1 | 2 ||
   *    _entity_dof_offsets   || 2 | 3 | 8 || 0 | 0 | 0 || ... || 1 | 2 | 3 ||
   *
   * @todo Try to use MultipleCodimMultipleGeomTypeMapper for variable size.
   * If the abstraction does not fit here, document why.
   */
  std::vector<SizeType> _gt_dof_offsets;
  std::vector<SizeType> _gt_entity_offsets;
  std::vector<SizeType> _entity_dof_offsets;
};


template<class Node, class MS>
TopologicAssociativityForestNode<Node,MS>::TopologicAssociativityForestNode(const MergingStrategy& merging_strategy, bool power_node)
  : _merging_strategy{ merging_strategy }
  , _fixed_size{ prioryFixedSize() }
  , _fixed_size_possible{ true }
{
  // all the entity sets below this node shall be the equal to each other
  if constexpr (std::equality_comparable<EntitySet>)
    forEachLeafNode(node(), [&](auto& leaf, auto path) {
      assert(entitySet() == leaf.entitySet());
    });

  // in case of power proto basis enable sharing states in children nodes
  if constexpr (Concept::ArrayTreeNode<Node> ||
                Concept::VectorTreeNode<Node>) {
    if (power_node and node().degree() > 0) {
      for (std::size_t i = 1; i < node().degree(); ++i)
        node().childStorage(i) = node().childStorage(0);
    }
  }
}


template<class Node, class MS>
constexpr std::size_t
TopologicAssociativityForestNode<Node,MS>::maxContainerDepth()
{
  if constexpr (Concept::LeafTreeNode<Node>) {
    return 1;
  } else {
    auto child_depth = [&]() {
      if constexpr (Concept::ArrayTreeNode<Node> ||
                    Concept::VectorTreeNode<Node>) {
        return Node::ChildType::maxContainerDepth();
      } else {
        static_assert(Node::isComposite);
        return unpackIntegerSequence(
          [](auto... i) {
            return std::max({
              TypeTree::template Child<Node, i>::maxContainerDepth()...});
          },
          std::make_index_sequence<Node::degree()>{});
      }
    }();
    if constexpr (containerBlocked())
      return child_depth + 1;
    else
      return child_depth;
  }
}


template<class Node, class MS>
constexpr auto TopologicAssociativityForestNode<Node,MS>::prioryFixedSize()
{
  if constexpr (Concept::LeafTreeNode<Node>) {
    // base case: query information from finite element map
    return Node::commonSizePerGeometryType().has_value();
  } else if constexpr (Concept::ArrayTreeNode<Node> ||
                       Concept::VectorTreeNode<Node>) {
    // all children have the same type so we inherit their fixed size
    return Node::ChildType::prioryFixedSize();
  } else {
    // make a conjunction of all the children types
    static_assert(Node::isComposite);
    auto unfold_children = [&](auto... i) {
      constexpr bool all_fixed_size =
        (TypeTree::template Child<Node, i>::prioryFixedSize() && ...);
      return std::integral_constant<bool, all_fixed_size>{};
    };
    auto indices = std::make_index_sequence<Node::degree()>{};
    return unpackIntegerSequence(unfold_children, indices);
  }
}

template<class Node, class MS>
auto TopologicAssociativityForestNode<Node,MS>::fixedSize() const noexcept
{
  if constexpr (prioryFixedSize())
    return std::true_type{};
  else
    return _fixed_size;
}

template<class Node, class MS>
const auto& TopologicAssociativityForestNode<Node,MS>::entitySet() const noexcept
{
  return _merging_strategy.entitySet();
}

template<class Node, class MS>
auto& TopologicAssociativityForestNode<Node,MS>::entitySet() noexcept
{
  return _merging_strategy.entitySet();
}

template<class Node, class MS>
bool TopologicAssociativityForestNode<Node,MS>::containsGeometry(SizeType gt_index) const noexcept
{
  return _gt_used[gt_index];
}

template<class Node, class MS>
bool TopologicAssociativityForestNode<Node,MS>::containsGeometry(const GeometryType& gt) const noexcept
{
  return containsGeometry(GlobalGeometryTypeIndex::index(gt));
}

template<class Node, class MS>
bool TopologicAssociativityForestNode<Node,MS>::containsCodim(SizeType codim) const noexcept
{
  return codimClosure().test(codim);
}

template<class Node, class MS>
typename TopologicAssociativityForestNode<Node,MS>::CodimFlag
TopologicAssociativityForestNode<Node,MS>::codimClosure() const noexcept
{
  assert(maxCodimCount() >= _codim_used.count());
  return _codim_used;
}

template<class Node, class MS>
auto TopologicAssociativityForestNode<Node,MS>::singleCodim() const noexcept
{
  if constexpr (maxCodimCount() == 1)
    return std::true_type{};
  else
    return (_codim_used.count() == 1);
}

template<class Node, class MS>
auto TopologicAssociativityForestNode<Node,MS>::disjointCodimClosure() const noexcept
{
  if constexpr (maxCodimCount() == 1)
    return std::integral_constant<bool, mayContainCodim(Indices::_0)>{};
  else
    return (_codim_used.count() == 1 and _codim_used[0]);
}

template<class Node, class MS>
typename TopologicAssociativityForestNode<Node,MS>::SizeType
TopologicAssociativityForestNode<Node,MS>::maxLocalCount() const noexcept
{
  return _max_local_coeff_count;
}

template<class Node, class MS>
void TopologicAssociativityForestNode<Node,MS>::debugInfo() const {
  using FEM = typename Node::ProtoBasis::FiniteElementMap;
  constexpr std::size_t fem_dim = FEM::Traits::FiniteElement::Traits::LocalBasisType::Traits::dimDomain;
  constexpr std::size_t fem_codim = EntitySet::dimension - fem_dim;

  std::cout << "Fixed Size per Geometry Type: " << bool(fixedSize()) << "\n";
  std::cout << "Blocked: " << bool(containerBlocked()) << "\n";
  if (fixedSize())
    std::cout << "  # Geometry Type, DOF Count\n";
  else
    std::cout << "  # Geometry Type, Entity Index, DOF Count ==\n";

  assert(Concept::LeafTreeNode<Node>); // TODO implement other nodes...
  for (std::size_t codim = fem_codim; codim <= EntitySet::dimension; ++codim) {
    for (const auto& gt : entitySet().indexSet().types(codim)) {
      const auto gt_index = GlobalGeometryTypeIndex::index(gt);
      if (fixedSize()) {
        std::cout << "  " << gt << ", " << blockCount(gt_index) << " \n";
      } else {
        auto gt_begin = std::begin(_gt_entity_offsets) + gt_index;
        auto size = *(gt_begin+1) - *gt_begin;
        for (std::size_t i = 0; i != size; ++i)
          std::cout << "  " << gt << ", " << i << ", " << _entity_dof_offsets[i + *gt_begin] << "\n";
      }
    }
  }
}

template<class Node, class MS>
typename TopologicAssociativityForestNode<Node,MS>::SizeType
TopologicAssociativityForestNode<Node,MS>::dimension() const noexcept
{
  SizeType dof_count = 0;
  forEachLeafNode(
    node(), [&](auto& leaf, auto path) { dof_count += leaf.blockCount(); });
  return dof_count;
}

template<class Node, class MS>
template<Concept::MultiIndex CompositionSuffix>
auto TopologicAssociativityForestNode<Node,MS>::containerIndexRange(
  CompositionSuffix comp_suff,
  SizeType gt_index,
  SizeType entity_index) const noexcept
{
  // Note: Multi-index is read Outer->Inner
  // only map known geometry indices
  assert(containsGeometry(gt_index));
  if constexpr (Concept::LeafTreeNode<Node>) {
    // (end of recursion) in case of leaf node. The fist multi-index is
    // guaranteed to be a range of multi-indices from 0 to block-count
    static_assert(CompositionSuffix::size() == 0);
    SizeType sz = blockCount(gt_index, entity_index);
    return std::views::iota(SizeType{0}, sz) | std::views::transform([](SizeType i){ return TypeTree::treePath(i); });
  } else {
    static_assert(CompositionSuffix::size() > 0);
    const auto child = front(comp_suff);
    // (continue recursion) get container index of the child node.
    const auto cir = node().child(child).containerIndexRange(pop_front(comp_suff), gt_index, entity_index);
    if constexpr (containerBlocked()) {
      // blocked merging: simply push front the child index
      return cir | std::views::transform([child](auto ci){ return push_front(ci, child); });
    } else {
      SizeType offset = 0;
      // lexicopgraphic merging: accumulate front the offest of the (child-1)
      if (child != 0) {
        if (fixedSize()) {
          offset = _gt_dof_offsets[gt_index * node().degree() + child - 1];
        } else {
          const auto index = (_gt_entity_offsets[gt_index] + entity_index) * node().degree() + child - 1;
          offset = _entity_dof_offsets[index];
        }
      }
      return cir | std::views::transform([offset](auto ci){ return accumulate_front(ci, offset); });
    }
  }
}

template<class Node, class MS>
constexpr auto TopologicAssociativityForestNode<Node,MS>::containerBlocked()
{
  // the blocking structure of a local space is given by the tag of its
  // children
  if constexpr (Concept::LeafTreeNode<Node>) {
    return std::false_type{};
  } else if constexpr (Concept::ArrayTreeNode<Node> ||
                       Concept::VectorTreeNode<Node>) {
    constexpr bool child_blocked = Node::ChildType::MergingStrategy::Blocked;
    return std::integral_constant<bool, child_blocked>{};
  } else if constexpr (Concept::TupleTreeNode<Node>) {
    auto unfold_children = [&](auto... i) {
      constexpr bool any_blocked =
        (TypeTree::template Child<Node, i>::MergingStrategy::Blocked || ...);
      constexpr bool all_blocked =
        (TypeTree::template Child<Node, i>::MergingStrategy::Blocked && ...);
      static_assert(all_blocked == any_blocked,
                    "All static children of a Space grouped "
                    "by entity must have the same blocking requirements");
      return std::integral_constant<bool, any_blocked>{};
    };
    auto indices = std::make_index_sequence<Node::degree()>{};
    return unpackIntegerSequence(unfold_children, indices);
  } else {
    static_assert(Dune::AlwaysFalse<Node>{}, "Not known Node Type");
  }
}

template<class Node, class MS>
template<Concept::MultiIndex ContainerSuffix>
std::size_t
TopologicAssociativityForestNode<Node,MS>::containerSize(const ContainerSuffix& cs,
                                                         SizeType gt_index,
                                                         SizeType entity_index) const noexcept
{
  // Note: Multi-index is read Inner->Outer
  // transform to reserved multi-index to avoid problems on pop back
  auto rcs = MultiIndex<SizeType, maxContainerDepth()>{ cs };
  // suffix wants the size for this node
  if (rcs.size() == 0)
    return node().blockCount(gt_index, entity_index);

  if constexpr (Concept::LeafTreeNode<Node>) {
    assert(rcs.size() == 1);
    return 0; // Leaf nodes contain no more indices
  } else {

    // helper to return from any child with a dynamic child index
    auto childContainerSize = [&](std::size_t child_i,
                                  auto next_suffix) -> SizeType {
      if constexpr (Concept::ArrayTreeNode<Node> ||
                    Concept::VectorTreeNode<Node>) {
        return node().child(child_i).containerSize(
          next_suffix, gt_index, entity_index);
      } else {
        static_assert(Concept::TupleTreeNode<Node>);
        // at this point we recoverd the index, but there is no way to
        // propagate its static information outside of this function (i.e. a
        // return type that depends on the child index)
        SizeType _size = std::numeric_limits<SizeType>::max();
        // make a loop over all nodes and check which one matches the child
        // index
        forEachChild(this->node(), [&](auto& child, auto i) {
          if (i == child_i)
            _size = child.containerSize(next_suffix, gt_index, entity_index);
        });
        return _size;
      }
    };

    // the next index to find out its size
    auto back_index = back(rcs);
    // task: find child the child node for whom this index corresponds
    if constexpr (containerBlocked()) {
      // easy case, the back_index is exactly the index of the child node
      return childContainerSize(back_index, pop_back(rcs));
    } else {
      // here we need to "recover" the child index that describes the
      // back_index (inverse of firstContainerIndex operation)
      assert(_gt_used[gt_index]);
      auto dof_begin = std::begin(fixedSize() ? _gt_dof_offsets : _entity_dof_offsets);
      if (fixedSize())
        dof_begin += gt_index * node().degree();
      else
        dof_begin += (_gt_entity_offsets[gt_index] + entity_index) * node().degree();
      auto dof_end = dof_begin + node().degree();
      auto dof_it = std::upper_bound(dof_begin, dof_end, back_index);
      auto next = accumulate_back(rcs, SizeType{ 0 });
      if (dof_it != dof_begin) {
        std::advance(dof_it, -1);
        assert(back(cs) >= *dof_it);
        next = accumulate_back(next, -(*dof_it));
      }
      std::size_t child_index = std::distance(dof_begin, dof_it);
      assert(node().degree() > child_index);
      return childContainerSize(child_index, next);
    };
  }
}

template<class Node, class MS>
void TopologicAssociativityForestNode<Node,MS>::update(EntitySet entity_set)
{
  forEachNode(node(), [&entity_set](auto& node) {
    node._merging_strategy.update(entity_set);
  });

  update();
}

template<class Node, class MS>
void TopologicAssociativityForestNode<Node,MS>::update()
{
  updateFixedSizeOrderings();
  if (not prioryFixedSize())
    updateVariableSizeOrderings();
}

template<class Node, class MS>
auto TopologicAssociativityForestNode<Node,MS>::blockCount(const SizeType gt_index,
                              const SizeType entity_index) const noexcept
{
  if constexpr (containerBlocked()) {
    static_assert(not Concept::LeafTreeNode<Node>);
    return node().degree();
  } else {
    assert(containsGeometry(gt_index));
    if (fixedSize())
      return SizeType{ blockCount(gt_index) };

    auto gt_offset = _gt_entity_offsets[gt_index] + entity_index;
    if constexpr (Concept::LeafTreeNode<Node>) {
      return _entity_dof_offsets[gt_offset];
    } else {
      const auto degree = node().degree();
      return _entity_dof_offsets[gt_offset * degree + degree - 1];
    }
  }
}

template<class Node, class MS>
auto TopologicAssociativityForestNode<Node,MS>::blockCount(std::size_t gt_index) const noexcept
{
  assert(fixedSize());
  if constexpr (containerBlocked()) {
    static_assert(not Concept::LeafTreeNode<Node>);
    return node().degree();
  } else {
    if constexpr (Concept::LeafTreeNode<Node>) {
      return _gt_dof_offsets[gt_index];
    } else {
      const auto degree = node().degree();
      return _gt_dof_offsets[gt_index * degree + degree - 1];
    }
  }
}

template<class Node, class MS>
[[nodiscard]] auto TopologicAssociativityForestNode<Node,MS>::blockCount() const noexcept
{
  if constexpr (containerBlocked()) {
    static_assert(not Concept::LeafTreeNode<Node>);
    return node().degree();
  } else {
    return _block_count;
  }
}


template<class Node, class MS>
template<class EntityCodim>
constexpr auto TopologicAssociativityForestNode<Node,MS>::mayContainCodim(EntityCodim entity_codim)
{
  if constexpr (Concept::LeafTreeNode<Node>) {
    constexpr std::size_t entity_dim = EntitySet::dimension - entity_codim;
    // dimension of the finite element domain (perhaps embedded on sub entities)
    using FEM = typename Node::ProtoBasis::FiniteElementMap;
    constexpr std::size_t fem_dim = FEM::Traits::FiniteElement::Traits::LocalBasisType::Traits::dimDomain;
    if constexpr (entity_dim > fem_dim) {
      // requested dim is higher than the finite element dimension thus not contained
      return std::false_type{};
    } else if constexpr (requires { FEM::hasDOFs(int{}); }) {
      // in this case we can check if a DOF is included or not
      constexpr std::size_t fem_codim = fem_dim - entity_dim;
      constexpr bool has_dofs = FEM::hasDOFs(static_cast<int>(fem_codim));
      return std::integral_constant<bool, has_dofs>{};
    } else {
      return std::true_type{};
    }
  } else if constexpr (Concept::ArrayTreeNode<Node> ||
                       Concept::VectorTreeNode<Node>) {
    return Node::ChildType::mayContainCodim(entity_codim);
  } else if constexpr (Node::isComposite) {
    auto unfold_children = [&](auto... i) {
      constexpr bool has_dofs =
        (TypeTree::template Child<Node, i>::mayContainCodim(entity_codim) || ...);
      return std::integral_constant<bool, has_dofs>{};
    };
    auto indices = std::make_index_sequence<Node::degree()>{};
    return unpackIntegerSequence(unfold_children, indices);
  } else {
    static_assert(Dune::AlwaysFalse<Node>{}, "Not known Node Type");
  }
}

template<class Node, class MS>
auto constexpr TopologicAssociativityForestNode<Node,MS>::maxCodimCount()
{
  auto sequence = std::make_index_sequence<1 + EntitySet::dimension>{};

  constexpr std::size_t count = Dune::unpackIntegerSequence(
    [&](auto... codim) {
      constexpr std::size_t one{ 1 }, zero{ 0 };
      return ((TopologicAssociativityForestNode::mayContainCodim(codim) ? one : zero) + ...);
    },
    sequence);
  return std::integral_constant<std::size_t, count>{};
}

template<class Node, class MS>
void TopologicAssociativityForestNode<Node,MS>::updateFixedSizeOrderings()
{
  const std::size_t dim = EntitySet::dimension;

  _fixed_size = prioryFixedSize();
  _max_local_coeff_count = 0;
  _block_count = 0;

  if constexpr (prioryFixedSize()) {
    // reset falgs and offsets
    _codim_used.reset();
    const auto gt_count = GlobalGeometryTypeIndex::size(dim);
    _gt_used.assign(gt_count, false);
    _gt_dof_offsets.assign(gt_count * std::max<std::size_t>(1, node().degree()), 0);
  }

  // fill out flags and offsets depending on the node type
  if constexpr (Concept::LeafTreeNode<Node>) {

    using FEM = typename Node::ProtoBasis::FiniteElementMap;
    constexpr std::size_t fem_dim = FEM::Traits::FiniteElement::Traits::LocalBasisType::Traits::dimDomain;
    constexpr std::size_t fem_codim = EntitySet::dimension - fem_dim;

    if constexpr (prioryFixedSize()) {
      for (std::size_t codim = fem_codim; codim <= EntitySet::dimension; ++codim) {
        for (const auto& gt : entitySet().indexSet().types(codim)) {
          SizeType size = node().protoBasis().finiteElementMap().size(gt);
          const auto gt_index = GlobalGeometryTypeIndex::index(gt);
          _gt_dof_offsets[gt_index] = size;
          _gt_used[gt_index] = size > 0;
          _block_count += size * entitySet().size(gt);
          assert(codim == dim - gt.dim());
          _codim_used[codim] = _codim_used[codim] or (size > 0);
        }
      }
      // collect max entity sides on fem dimension for an entity of codimension 0
      int max_sub_entities = 0;
      for (const auto& gt : entitySet().indexSet().types(0)) {
        using Dune::referenceElement;
        auto ref_el = referenceElement<double, EntitySet::dimension>(gt);
        max_sub_entities = std::max(max_sub_entities, ref_el.size(EntitySet::dimension - fem_dim));
      }
      node().setMaxSubEntities(max_sub_entities);
      _max_local_coeff_count = max_sub_entities * node().protoBasis().finiteElementMap().maxLocalSize();
    }
  } else {
    forEachChild(this->node(), [&](auto& child, auto i) {
      // first, set up child gt collection
      child.updateFixedSizeOrderings();
      // then, accumulate child results to this node
      if constexpr (prioryFixedSize()) {
        // this node can only be fixed size if child is also fixed size
        assert(child.prioryFixedSize());

        // properties contained in child nodes are also contained here
        for (std::size_t codim = 0; codim <= dim; ++codim)
          _codim_used[codim] =
            _codim_used[codim] or child.containsCodim(codim);

        for (std::size_t gt = 0; gt < _gt_used.size(); ++gt)
          _gt_used[gt] = _gt_used[gt] or child.containsGeometry(gt);

        _max_local_coeff_count += child.maxLocalCount();

        if (not containerBlocked())
          _block_count += child.blockCount();

        // get size of child nodes
        for (std::size_t gt = 0; gt < _gt_used.size(); ++gt)
          _gt_dof_offsets[gt * node().degree() + i] = child.blockCount(gt);
      }
    });
  }

  if constexpr (prioryFixedSize()) {
    // finally, convert child gt sizes into offsets
    auto it = std::begin(_gt_dof_offsets);
    const auto advance = std::max<std::size_t>(1, node().degree());
    while (it != std::end(_gt_dof_offsets))
      it = std::partial_sum(it, it + advance, it);
  }
}

template<class Node, class MS>
void TopologicAssociativityForestNode<Node,MS>::allocateVariableSizeOrdering()
{
  static_assert(not prioryFixedSize());
  _codim_used.reset();
  const auto gt_count = GlobalGeometryTypeIndex::size(EntitySet::dimension);
  _gt_used.assign(gt_count, false);
  _gt_dof_offsets.assign(gt_count * std::max<std::size_t>(1, node().degree()), GT_UNUSED);
  _gt_entity_offsets.assign(gt_count + 1, 0);
}

template<class Node, class MS>
template<class Entity>
void TopologicAssociativityForestNode<Node,MS>::collectLeafGeometryTypes(const Entity& entity)
{
  static_assert(not prioryFixedSize());
  static_assert(Concept::LeafTreeNode<Node>);
  static_assert(Dune::Concept::EntityExtended<Entity>);
  assert(not fixedSize());

  using FEM = typename Node::ProtoBasis::FiniteElementMap;
  constexpr std::size_t fem_dim = FEM::Traits::FiniteElement::Traits::LocalBasisType::Traits::dimDomain;
  constexpr std::size_t fem_codim = EntitySet::dimension - fem_dim;

  const FEM& fem = node().protoBasis().finiteElementMap();
  std::size_t max_coeff_count = 0;
  for (const auto& sub_entity : subEntities(entity, Dune::Codim<fem_codim>{})) {
    const auto& finite_element = fem.find(sub_entity);
    using FEM = typename Node::ProtoBasis::FiniteElementMap;
    using FESwitch = FiniteElementInterfaceSwitch<typename FEM::Traits::FiniteElement>;
    const auto& coeffs = FESwitch::coefficients(finite_element);
    max_coeff_count += coeffs.size();

    const auto& ref_el = referenceElement(sub_entity.geometry());
    for (std::size_t i = 0; i < coeffs.size(); ++i) {
      const auto& key = coeffs.localKey(i);
      auto gt_index = GlobalGeometryTypeIndex::index(ref_el.type(key.subEntity(), key.codim()));
      _gt_used[gt_index] = true;
      _codim_used.set(fem_codim + key.codim());
    }
  }
  _max_local_coeff_count = std::max<std::size_t>(_max_local_coeff_count, max_coeff_count);
  node().setMaxSubEntities(std::max<int>(node().maxSubEntities(), entity.subEntities(fem_codim)));
}

template<class Node, class MS>
void TopologicAssociativityForestNode<Node,MS>::collectGeometryTypes()
{
  _fixed_size_possible = true;

  if constexpr (not Concept::LeafTreeNode<Node>) {
    forEachChild(this->node(), [&](auto& child, auto path) {
      child.collectGeometryTypes();

      if constexpr (not prioryFixedSize()) {
        // properties contained in child nodes are also contained here
        for (std::size_t codim = 0; codim <= EntitySet::dimension; ++codim)
          _codim_used[codim] =
            _codim_used[codim] or child.containsCodim(codim);

        for (std::size_t gt = 0; gt < _gt_used.size(); ++gt)
          _gt_used[gt] = _gt_used[gt] or child.containsGeometry(gt);
      }
    });
  }

  // create offset of indices for contained geometry types
  if constexpr (not prioryFixedSize()) {
    for (std::size_t codim = 0; codim <= EntitySet::dimension; ++codim) {
      for (const auto& gt : entitySet().indexSet().types(codim)) {
        const auto gt_index = GlobalGeometryTypeIndex::index(gt);
        if (containsGeometry(gt_index))
          _gt_entity_offsets[gt_index + 1] = entitySet().indexSet().size(gt);
      }
      std::partial_sum(std::begin(_gt_entity_offsets),
                        std::end(_gt_entity_offsets),
                        std::begin(_gt_entity_offsets));
      _entity_dof_offsets.assign(_gt_entity_offsets.back() * std::max<std::size_t>(node().degree(), 1), 0);
    }
  }
}

template<class Node, class MS>
template<class Entity>
void TopologicAssociativityForestNode<Node,MS>::collectEntitySizes(const Entity& entity, std::vector<SizeType>& gt_cache)
{
  static_assert(not prioryFixedSize());
  static_assert(Concept::LeafTreeNode<Node>);
  if (_fixed_size_possible)
    std::fill(gt_cache.begin(), gt_cache.end(), GT_UNUSED);

  using FEM = typename Node::ProtoBasis::FiniteElementMap;
  constexpr std::size_t fem_dim = FEM::Traits::FiniteElement::Traits::LocalBasisType::Traits::dimDomain;
  constexpr std::size_t fem_codim = EntitySet::dimension - fem_dim;

  const FEM& fem = node().protoBasis().finiteElementMap();
  for (std::size_t s = 0; s != entity.subEntities(fem_codim); ++s) {
    const auto& sub_entity = [&]{
      if constexpr (fem_codim == 0)
        return entity;
      else
        return entity.template subEntity<fem_codim>(s);
    }();

    const auto& finite_element = fem.find(sub_entity);
    if (finite_element.type() != entity.type())
      DUNE_THROW(RangeError, "Dune::GeometryType of the local finite element and entity do not match!");
    using FEM = typename Node::ProtoBasis::FiniteElementMap;
    using FESwitch =
      FiniteElementInterfaceSwitch<typename FEM::Traits::FiniteElement>;
    const auto& coeffs = FESwitch::coefficients(finite_element);

    const auto& ref_el = referenceElement(sub_entity.geometry());
    for (std::size_t dof = 0; dof != coeffs.size(); ++dof) {
      const LocalKey& key = coeffs.localKey(dof);
      const SizeType gt_index = GlobalGeometryTypeIndex::index(ref_el.type(key.subEntity(), key.codim()));
      const SizeType entity_index = entitySet().indexSet().subIndex(sub_entity, key.subEntity(), fem_codim + key.codim());
      const SizeType index = _gt_entity_offsets[gt_index] + entity_index;
      gt_cache[gt_index] = _entity_dof_offsets[index] = std::max<SizeType>(_entity_dof_offsets[index], key.index() + 1);
    }
  }

  // as long as we haven't discarded possible fixed size, we try to find
  // out if the seen geometry types have fixed size
  if (_fixed_size_possible) {
    for (std::size_t i = 0; i < gt_cache.size(); ++i) {
      // update unused entries
      if (_gt_dof_offsets[i] == GT_UNUSED)
        _gt_dof_offsets[i] = gt_cache[i];
      // if cache does not match global gt sizes, we need to discard fixed
      // size computations
      if (_gt_dof_offsets[i] != gt_cache[i]) {
        _fixed_size_possible = false;
        break;
      }
    }
  }
}

template<class Node, class MS>
void TopologicAssociativityForestNode<Node,MS>::accumulateEntityOffsets()
{
  _block_count = 0;
  if constexpr (Concept::LeafTreeNode<Node>) {
    // if we did't discard fixed size by this point, we can use the
    // fixed size geometry type sizes
    if (_fixed_size_possible) {
      _entity_dof_offsets.clear(); // discard individual entity sizes
      _fixed_size = true;
    }
    // mask out GT_UNUSED for geometry types that really weren't used
    for (std::size_t codim = 0; codim <= EntitySet::dimension; ++codim) {
      for (const auto& gt : entitySet().indexSet().types(codim)) {
        auto& size = _gt_dof_offsets[GlobalGeometryTypeIndex::index(gt)];
        if (size == GT_UNUSED)
          size = 0;
        if (_fixed_size)
          _block_count += size * entitySet().size(gt);
      }
    }
    if (not _fixed_size)
      _block_count = std::accumulate(std::begin(_entity_dof_offsets), std::end(_entity_dof_offsets), 0);
  } else {
    // update node properties
    _fixed_size_possible = true;
    forEachChild(this->node(), [&](auto& child, auto path) {
      // update sub-tree
      child.accumulateEntityOffsets();
      _fixed_size_possible &= child.fixedSize();
      _max_local_coeff_count += child.maxLocalCount();
    });

    const std::size_t dim = EntitySet::dimension;
    const std::size_t gt_count = GlobalGeometryTypeIndex::size(dim);
    if (_fixed_size_possible) {
      // we need to update gt sizes from children and convert them to offsets
      forEachChild(this->node(), [&](auto& child, auto i) {
        for (std::size_t codim = 0; codim <= EntitySet::dimension; ++codim) {
          for (const auto& gt : entitySet().indexSet().types(codim)) {
            const auto gt_index = GlobalGeometryTypeIndex::index(gt);
            const auto gt_offset = gt_index * node().degree() + i;
            const auto cb_count = child.blockCount(gt_index);
            _gt_dof_offsets[gt_offset] = cb_count;
            _block_count += cb_count * entitySet().size(gt);
            if (i != 0)
              _gt_dof_offsets[gt_offset] = _gt_dof_offsets[gt_offset - 1] + cb_count;
          }
        }
      });

      _fixed_size = true;
    } else {
      // no fixed size was possible, save offsets for each entity:
      //   for every entity we already have block count,
      //   then, we just need to carry such count to the next entity value
      SizeType index = 0;
      for (SizeType gt = 0; gt < gt_count; ++gt) {
        if (not containsGeometry(gt))
          continue;
        assert(_gt_entity_offsets[gt] <= _gt_entity_offsets[gt + 1]);
        const SizeType entity_count =
          _gt_entity_offsets[gt + 1] - _gt_entity_offsets[gt];
        for (SizeType e_index = 0; e_index < entity_count; ++e_index) {
          SizeType carry = 0;
          forEachChild(this->node(), [&](auto& child, auto path) {
            carry += child.blockCount(gt, e_index);
            _entity_dof_offsets[index++] = carry;
          });
          _block_count += containerBlocked() ? (carry != 0) : carry;
        }
      }
    }
  }
}

template<class Node, class MS>
void TopologicAssociativityForestNode<Node,MS>::updateVariableSizeOrderings()
{

  forEachNode(node(), []<class T>(T& node, auto path) {
    if constexpr (not T::prioryFixedSize())
      node.allocateVariableSizeOrdering();
  });

  for (const auto& entity : elements(entitySet())) {
    forEachLeafNode(node(), [&]<class T>(T& leaf, auto path) {
      if constexpr (not T::prioryFixedSize())
        leaf.collectLeafGeometryTypes(entity);
    });
  }

  collectGeometryTypes();

  { // construct cache outside entity collection to avoid reallocation
    const std::size_t dim = EntitySet::dimension;
    std::vector<SizeType> gt_cache(GlobalGeometryTypeIndex::size(dim), 0);

    for (const auto& entity : elements(entitySet())) {
      forEachLeafNode(node(), [&]<class T>(T& leaf, auto path) {
        if constexpr (not T::prioryFixedSize())
          leaf.collectEntitySizes(entity, gt_cache);
      });
    }
  }
  accumulateEntityOffsets();
}


} // namespace Dune::PDELab::Impl

#endif // DUNE_PDELAB_BASIS_ORDERING_TOPOLOGIC_ASSOCIATIVITY_FOREST_NODE_HH
