#ifndef DUNE_PDELAB_BASIS_TOPOLOGIC_ASSOCIATIVITY_FOREST_NODE_HH
#define DUNE_PDELAB_BASIS_TOPOLOGIC_ASSOCIATIVITY_FOREST_NODE_HH

#include <dune/pdelab/common/multiindex.hh>
#include <dune/pdelab/common/tree_traversal.hh>

#include <dune/pdelab/concepts/multiindex.hh>
#include <dune/pdelab/concepts/treenode.hh>

#include <dune/grid/concepts/entity.hh>

#include <dune/typetree/treepath.hh>
#include <dune/typetree/childextraction.hh>

#include <dune/localfunctions/common/interfaceswitch.hh>
#include <dune/localfunctions/common/localkey.hh>

#include <dune/geometry/type.hh>
#include <dune/geometry/typeindex.hh>
#include <dune/geometry/referenceelements.hh>

#include <dune/common/rangeutilities.hh>

#include <vector>
#include <algorithm>
#include <numeric>
#include <span>
#include <memory>
#include <version>

namespace Dune::PDELab::Impl {


  //! Utility to allocate and assing storage of offsets
  template<class Value>
  auto make_span_storage(std::size_t size, Value value) {
  #if __cpp_lib_smart_ptr_for_overwrite >= 202002L
    std::unique_ptr<Value[]> storage = std::make_unique_for_overwrite<Value[]>(size);
  #else
    std::unique_ptr<Value[]> storage = std::unique_ptr<Value[]>(new Value[size]);
  #endif
    std::span<Value> span = {storage.get(), size};
    std::uninitialized_fill_n(std::begin(span), size, value);
    return std::make_tuple(std::move(storage), std::move(span));
  }

 /**
 * @class TopologicAssociativityForestNode
 * @brief Represents a topological associativity forest for managing degrees of freedom in finite element spaces.
 *
 * This class is designed to interleave and merge degrees of freedom from product spaces of finite elements.
 * It forms a forest of trees, where each tree corresponds to the degrees of freedom associated with a topological
 * entity of a grid. The class itself is a tree node, but it does not directly represent the tree of blocks; instead,
 * it provides the means to construct and traverse these trees by exposing their hierarchy and sizes.
 *
 * The primary purpose of this class is to facilitate the indexing of containers that hold the coefficients of finite
 * element computations. It achieves this by interleaving all trees in its children's topological associativity forests
 * with their common topological entity, forming a unified tree structure below each entity of the grid view.
 *
 * Composition of forests: topologic associativity 'e' on trees is always interleaved on each tree of the forest.
 *
 *                        e
 *                       / \
 *                      /   \
 *    e     e    =>    c     d
 *   / \   / \        / \   / \
 *  o   o o   o      o   o o   o
 *
 * Lexicographical merging: nodes of underlying children are collapsed into the current node.
 *
 *       e
 *      / \               e
 *     /   \            /| |\
 *    c     d    =>    | | | |
 *   / \   / \         o o o o
 *  o   o o   o
 *
 * @tparam Node The type of the tree node that inherits this class, using the Barton–Nackman trick for CRTP.
 * @tparam MS   A merging strategy that defines how children nodes are merged (lexicographically or preserving blocks).
 *
 * @details
 * The class supports both fixed-size and variable-size maps:
 * - Fixed-size maps are used when all entities of a given geometry type have the same structure, allowing for more
 *   efficient memory usage and better cache performance.
 * - Variable-size maps are used when each entity may have different sizes, requiring individual storage of offsets.
 *
 * The class provides methods to query the structure of the forest, such as the range of indices for a given entity
 * and the size of blocks at different levels of the hierarchy. It also supports updating the forest structure based
 * on a new entity set.
 *
 * Key Methods:
 * - `containerIndexRange`: Provides the range of transformed indices to the leaf nodes of the original tree.
 * - `containerSize`: Determines the size of the hierarchical containers that hold the blocks of degrees of freedom.
 * - `update`: Updates the indices of the forest based on a given entity set, using a depth-first algorithm.
 *
 * The merging strategy influences how the trees of blocks are merged:
 * - Lexicographical merging: Children nodes are merged in a lexicographical order.
 * - Blocked merging: The original blocked structure of the tree is preserved.
 *
 * @note This class does not hold the contents of the forest, only its structure. The actual degrees of freedom are
 * managed externally, and this class provides the indexing and mapping necessary to access them efficiently.
 *
 * @note The multi-indices generated by this map follow a top-to-bottom ordering, meaning that the leftmost indices indicate
 * a tree path from the upper part of a tree of indices, while the rightmost indices indicate lower parts of the tree.
 * This ordering is consistent with the Basis in dune-functions and contrary to the GridFunctionSpace orderings in PDELab.
 *
 * @warning The mappings produced by this class are almost dense. Cases where the map is not dense occur when the blocked
 * structure induces a multi-index whose suffix has a 0-size range on the last index. This happens when there is at
 * least one blocking merging strategy within the tree and the finite elements of the different leaf nodes cover
 * different codimensions. An example is Taylor-Hood elements of degree 1, where all nodes are entity-ordered with
 * a blocked merging strategy: the root node provides the whole tree suffix to the multi-index, but the child node
 * corresponding to the pressure element has no degrees of freedom in the facets of the elements.
 *
 * @todo Implement compile-time checks to ensure dense ordering is guaranteed when possible.
 */
template<class Node, class GV, class MS>
class TopologicAssociativityForestNode
{
  // Notice that by this point `Node` is an incomplete type because it will only
  // be completed after inheriting from this class (Barton–Nackman trick)
  // Therefore, we can only inquiry its contents after completion, which
  // is why we only deduce types on functions and not in the class scope.

public:
  using GridView = GV;
  // type of merging strategy
  using MergingStrategy = MS;
  // index type
  using SizeType = typename GridView::IndexSet::IndexType;
private:
  // type for bitset information of used codimensions
  using CodimFlag = std::bitset<GridView::dimensionworld+1>;
  // key value to identify geometry types that are not mapped by this class
  static constexpr SizeType GT_UNUSED = std::numeric_limits<SizeType>::max();

  // We share private methods with other nodes of the same kind. This allows
  // to have tree algorithms in one templated class and still keep internals
  // encapsulated to the outside.
  // But with great power comes great responsability:
  //   DO NOT MODIFY OTHER NODE PRIVATE MEMBERS!
  //   Otherwise code becomes -more- unmaintainable and harder to reason about,
  //   instead create a function that describes the performed action
  template<class Node_, class GV_, class MS_>
  friend class TopologicAssociativityForestNode;

public:

  /** @brief Construct a topologic associativity forest out of a merging strategy
   */
  TopologicAssociativityForestNode(const GridView& grid_view, const MergingStrategy& merging_strategy);

  TopologicAssociativityForestNode(const TopologicAssociativityForestNode&) = delete;
  TopologicAssociativityForestNode(TopologicAssociativityForestNode&&) = default;

  TopologicAssociativityForestNode& operator=(const TopologicAssociativityForestNode&) = delete;
  TopologicAssociativityForestNode& operator=(TopologicAssociativityForestNode&&) = default;

  //! Maximum size of multi-indices
  [[nodiscard]] static constexpr std::size_t maxContainerDepth();

  //! Whether all leaf nodes have the same fixed DOF size per geometry type at compile time
  [[nodiscard]] static constexpr auto fixedSizePerGeometryTypeStatic();

  //! Whether this ordering has fixed DOF size per geometry type
  [[nodiscard]] auto fixedSizePerGeometryType() const noexcept;

  // Entity set of the ordering
  [[nodiscard]] const auto& gridView() const noexcept;

  // Entity set of the ordering
  [[nodiscard]] auto& gridView() noexcept;

  //! Whether a geometry type is mapped to multi-indices within this object
  [[nodiscard]] bool containsGeometry(SizeType gt_index) const noexcept;

  //! Whether a geometry type is mapped to multi-indices within this object
  [[nodiscard]] bool containsGeometry(const GeometryType& gt) const noexcept;

  // Whether a codimension is mapped to multi-indices within this object
  [[nodiscard]] bool containsCodim(SizeType codim) const noexcept;

  // Get bitset of the codimenions that this object is able to map
  [[nodiscard]] CodimFlag codimClosure() const noexcept;

  //! Whether DOFs only exist in one codimension
  //! @details Note that when this is true, all the multi-indices can be
  //! constructed from the container index multi-index and the block count
  //! of a given tree (i.e. no need to inspect the other local keys of the
  //! reference local element).
  [[nodiscard]] auto singleCodim() const noexcept;

  //! Whether DOFs are only attached to the volume part of the entities.
  //! @details If true, it should hint to DG and FV function spaces.
  [[nodiscard]] auto disjointCodimClosure() const noexcept;

  //! Maximum number of coefficients that may be associated to local finite elements
  //! @details This is useful to know when finite elements have different sizes per entity
  [[nodiscard]] SizeType maxLocalCount() const noexcept;

  //! Print offsets to debug orderings
  //! @todo Implement other nodes other than leaf...
  void debugInfo() const;

  //! Counts the number of blocks in the leaf nodes
  [[nodiscard]] SizeType dimension() const noexcept;

  /**
   * @brief Retrieves a range of container multi-indices (Outer2Inner) for a specified entity and leaf node in the tree.
   *
   * @details This function provides the range of multi-indices for a given entity and leaf node, considering the
   * merging strategy at the current level.
   *
   * @warning The merging strategy at this level affects the result. Therefore, the range obtained from
   * `child(path).containerIndexRange(...)` may differ from `node().containerIndexRange(path,...)`.
   *
   * @tparam TreePath             The type representing the path to a leaf node in the tree.
   * @param path                  The path to the required leaf node.
   * @param gt_index              The index of the geometry type.
   * @param entity_index          The index of the entity.
   * @return Concept::MultiIndex  The range of multi-indices from Outer2Inner.
   */
  template<Concept::MultiIndex TreePath>
  [[nodiscard]] auto containerIndexRange(
    TreePath path,
    SizeType gt_index,
    SizeType entity_index) const noexcept;

  //! Whether the forest trees shall be blocked
  [[nodiscard]] static constexpr auto treesBlocked();

  /**
   * @brief Calculates the total number of indices for any suffix of the multi-indices in the tree of blocks.
   *
   * @details This function determines the size induced by a given suffix of a container index. The suffix is derived
   * from the multi-indices generated by this object, specifically from the `containerIndexRange` method. The size
   * refers to the range of suffixes on the next level of multi-indices.
   *
   * For example, if a node tree generates the following Inner2Outer multi-indices for a given entity:
   * (0,0,0), (0,1,0), ..., (0,10,0), then the suffix (-,-,0) induces a size of 11, while suffixes like (-,0,0),
   * (-,1,0), etc., each induce a size of 1.
   *
   * @warning The input container suffix is expected to be reversed with respect to the output of `containerIndexRange`.
   *
   * @tparam ContainerSuffix The type representing the suffix of a multi-index.
   * @param cs               A suffix of an Inner2Outer multi-index from this map.
   * @param gt_index         The index of the geometry type.
   * @param entity_index     The index of the entity.
   * @return std::size_t     The size induced by the multi-index suffix.
   */
  template<Concept::MultiIndex ContainerSuffix>
  [[nodiscard]] std::size_t containerSize(const ContainerSuffix& cs,
                                          SizeType gt_index,
                                          SizeType entity_index) const noexcept;

  /**
   * @brief Updates the grid view on all nodes of the tree
   * @warning This does not update the indices, use `initializeIndices` to update other contents
   * @param entity_set    Entity set on from where to generate the forest
   */
  void update(GridView entity_set);


  /**
   * @brief Updates the indices of the forest with respect to a new entity set
   * @details Calling this method produces a depth first algorithm:
   * - Before every node: Allocate and set-up node.
   * - Before/After children: Carry partial calculation of the children sizes
   * - After every node: Calculate final sizes of children and accumulate to obtain offets.
   * @warning This method only needs to be called from the final root node of the tree of forests.
   */
  void initializeIndices();

  //! Number of blocks associated to a given entity at this tree level
  [[nodiscard]] auto blockCount(const SizeType gt_index,
                                const SizeType entity_index) const noexcept;

  //! Number of blocks associated to a given entity (fixed size version) at this tree level
  [[nodiscard]] auto blockCount(std::size_t gt_index) const noexcept;

  //! Total number of blocks on all entities at this tree level
  [[nodiscard]] auto blockCount() const noexcept;

  //! Priory compile-time information if a given codimension may contain DOFs wrt a grid entity
  //! @details If false, there is a guarantee that this map will never contain such a codimension.
  //! If true, codimension may or may not be used at run-time.
  template<class EntityCodim>
  [[nodiscard]] static constexpr auto mayContainCodim(EntityCodim entity_codim);

private:

  //! Compile-time information of maximum codimensions used by this map
  //! @note Less codimenions may be actually used at run-time.
  [[nodiscard]] static auto constexpr maxCodimCount();

  //! Setup ordering for fixed size maps
  //! @warning Recursive function, only call this from root node.
  void updateFixedSizeOrderings();

  //! Pre-allocate objects on this node related to the variable size ordering
  void allocateVariableSizeOrdering();

  //! Collect used geometry types on leaf nodes (variable size)
  template<class Entity>
  void collectLeafGeometryTypes(const Entity& entity);

  //! Collect geometry types for all nodes (variable size)
  //! @note Use after every leaf node called `collectLeafGeometryTypes`
  //! @warning Recursive function, only call this from root node.
  void collectGeometryTypes();

  //! Gather sizes for entity sizes on the leaf node from local keys (variable size)
  //! @note Use this after geometry types have been collected
  //! @note This class additionally checks if sizes change between different
  //! entities, thus, allowing us to know if we can compress variable size data
  //! into fixed size data.
  template<class Entity>
  void collectEntitySizes(const Entity& entity, std::vector<SizeType>& gt_cache);

  //! Convert size vectors into offset vectors
  //! This class identifies first if fixed size is possible, then accumulates
  //! offsets in the corresponding data structure.
  //! @warning Recursive function, only call this from root node.
  void accumulateEntityOffsets();

  //! Setup ordering for variable size maps
  //! @note Recursive function, only call this from root node.
  void updateVariableSizeOrderings();

  //! If possible, use shared data from sibling node
  void useDataFromSibling(const auto& other);

  //! If possible, make all children share data among them
  //! @warning Recursive function, only call this from root node.
  void shareChildenData();

  //! Cast to const node implementation (Barton–Nackman trick)
  const Node& node() const noexcept { return static_cast<const Node&>(*this); }

  //! Cast to node implementation (Barton–Nackman trick)
  Node& node() noexcept { return static_cast<Node&>(*this); }

  GridView _grid_view;
  CodimFlag _codim_used;
  std::vector<bool> _gt_used;
  MergingStrategy _merging_strategy;
  std::size_t _max_local_coeff_count, _block_count;
  bool _fixed_size, _fixed_size_possible;

  /**
   *  Data for this node may be stored in fixed or variable size form:
   *
   * * Fixed Size:
   *    In this case, all entities of a given geometry type look the same.
   *    Thus, we just need to store the offset between nodes for each geometry
   *    type.
   *
   *    gt_index        ||    cell   || ... ||   vertex  || ... ||
   *    child_index     || 0 | 1 | 2 || ... || 0 | 1 | 2 || ... ||
   *    _gt_dof_offsets || 2 | 3 | 8 || ... || 1 | 2 | 3 || ... ||
   *
   * * Variable Size:
   *    In this case, every entity has potentially different sizes so we have
   *    to store each offset individully. This information is stored in the
   *    `_entity_dof_offsets`. Since grids have a different indexation for
   *    each geometry type, we store an offset for these geometry types in
   *    `_gt_entity_offsets`. This works similarly as the
   *    `MultipleCodimMultipleGeomTypeMapper` object in dune-grid works.
   *
   *    gt_index              || cell                          || vertex    ||
   *    _gt_entity_offsets    || *                             || *         ||
   *                             |                                |
   *                             v                                v
   *    entity_index          ||   cell0   ||   cell1   || ... ||  vertex0  ||
   *    child_index           || 0 | 1 | 2 || 0 | 1 | 2 || ... || 0 | 1 | 2 ||
   *    _entity_dof_offsets   || 2 | 3 | 8 || 0 | 0 | 0 || ... || 1 | 2 | 3 ||
   *
   */

  std::span<SizeType> _gt_dof_offsets;
  std::span<SizeType> _gt_entity_offsets;
  std::span<SizeType> _entity_dof_offsets;

  std::shared_ptr<SizeType[]> _gt_dof_offsets_storage;
  std::shared_ptr<SizeType[]> _gt_entity_offsets_storage;
  std::shared_ptr<SizeType[]> _entity_dof_offsets_storage;
};


template<class Node, class GV, class MS>
TopologicAssociativityForestNode<Node,GV,MS>::TopologicAssociativityForestNode(const GridView& grid_view, const MergingStrategy& merging_strategy)
  : _grid_view{ grid_view }
  , _merging_strategy{ merging_strategy }
  , _fixed_size{ fixedSizePerGeometryTypeStatic() }
  , _fixed_size_possible{ true }
{
  // All the entity sets below this node shall be the equal to each other.
  // Note that entity sets are not comparable in general.
  if constexpr (Concept::ParentTreeNode<Node>)
    Dune::PDELab::forEachChild(this->node(), [&]<class T>(const T& node) {
      static_assert(std::is_same_v<GridView, typename T::GridView>);
      if constexpr (std::equality_comparable<GridView>)
        assert(gridView() == node.gridView());
    });
}

template<class Node, class GV, class MS>
constexpr std::size_t
TopologicAssociativityForestNode<Node,GV,MS>::maxContainerDepth()
{
  if constexpr (Concept::LeafTreeNode<Node>) {
    return 1;
  } else {
    auto child_depth = [&]() {
      if constexpr (Concept::ArrayTreeNode<Node> ||
                    Concept::VectorTreeNode<Node>) {
        return Node::ChildType::maxContainerDepth();
      } else {
        static_assert(Node::isComposite);
        return unpackIntegerSequence(
          [](auto... i) {
            return std::max({
              TypeTree::template Child<Node, i>::maxContainerDepth()...});
          },
          std::make_index_sequence<Node::degree()>{});
      }
    }();
    if constexpr (MergingStrategy::Blocked)
      return child_depth + 1;
    else
      return child_depth;
  }
}


template<class Node, class GV, class MS>
constexpr auto TopologicAssociativityForestNode<Node,GV,MS>::fixedSizePerGeometryTypeStatic()
{
  if constexpr (Concept::LeafTreeNode<Node>) {
    // base case: query information from finite element map
    return Node::commonSizePerGeometryType().has_value();
  } else if constexpr (Concept::ArrayTreeNode<Node> ||
                       Concept::VectorTreeNode<Node>) {
    // all children have the same type so we inherit their fixed size
    return Node::ChildType::fixedSizePerGeometryTypeStatic();
  } else {
    // make a conjunction of all the children types
    static_assert(Node::isComposite);
    auto unfold_children = [&](auto... i) {
      constexpr bool all_fixed_size =
        (TypeTree::template Child<Node, i>::fixedSizePerGeometryTypeStatic() && ...);
      return std::integral_constant<bool, all_fixed_size>{};
    };
    auto indices = std::make_index_sequence<Node::degree()>{};
    return unpackIntegerSequence(unfold_children, indices);
  }
}

template<class Node, class GV, class MS>
auto TopologicAssociativityForestNode<Node,GV,MS>::fixedSizePerGeometryType() const noexcept
{
  if constexpr (fixedSizePerGeometryTypeStatic())
    return std::true_type{};
  else
    return _fixed_size;
}

template<class Node, class GV, class MS>
const auto& TopologicAssociativityForestNode<Node,GV,MS>::gridView() const noexcept
{
  return _grid_view;
}

template<class Node, class GV, class MS>
auto& TopologicAssociativityForestNode<Node,GV,MS>::gridView() noexcept
{
  return _grid_view;
}

template<class Node, class GV, class MS>
bool TopologicAssociativityForestNode<Node,GV,MS>::containsGeometry(SizeType gt_index) const noexcept
{
  return _gt_used[gt_index];
}

template<class Node, class GV, class MS>
bool TopologicAssociativityForestNode<Node,GV,MS>::containsGeometry(const GeometryType& gt) const noexcept
{
  return containsGeometry(GlobalGeometryTypeIndex::index(gt));
}

template<class Node, class GV, class MS>
bool TopologicAssociativityForestNode<Node,GV,MS>::containsCodim(SizeType codim) const noexcept
{
  return codimClosure().test(codim);
}

template<class Node, class GV, class MS>
typename TopologicAssociativityForestNode<Node,GV,MS>::CodimFlag
TopologicAssociativityForestNode<Node,GV,MS>::codimClosure() const noexcept
{
  assert(maxCodimCount() >= _codim_used.count());
  return _codim_used;
}

template<class Node, class GV, class MS>
auto TopologicAssociativityForestNode<Node,GV,MS>::singleCodim() const noexcept
{
  if constexpr (maxCodimCount() == 1)
    return std::true_type{};
  else
    return (_codim_used.count() == 1);
}

template<class Node, class GV, class MS>
auto TopologicAssociativityForestNode<Node,GV,MS>::disjointCodimClosure() const noexcept
{
  if constexpr (maxCodimCount() == 1)
    return std::integral_constant<bool, mayContainCodim(Indices::_0)>{};
  else
    return (_codim_used.count() == 1 and _codim_used[0]);
}

template<class Node, class GV, class MS>
typename TopologicAssociativityForestNode<Node,GV,MS>::SizeType
TopologicAssociativityForestNode<Node,GV,MS>::maxLocalCount() const noexcept
{
  return _max_local_coeff_count;
}

template<class Node, class GV, class MS>
void TopologicAssociativityForestNode<Node,GV,MS>::debugInfo() const {
  using FEM = typename Node::ProtoBasis::FiniteElementMap;
  constexpr std::size_t fem_dim = FEM::Traits::FiniteElement::Traits::LocalBasisType::Traits::dimDomain;
  constexpr std::size_t fem_codim = GridView::dimension - fem_dim;

  std::cout << "Fixed Size per Geometry Type: " << bool(fixedSizePerGeometryType()) << "\n";
  std::cout << "Blocked: " << bool(MergingStrategy::Blocked) << "\n";
  if (fixedSizePerGeometryType())
    std::cout << "  # Geometry Type, DOF Count\n";
  else
    std::cout << "  # Geometry Type, Entity Index, DOF Count ==\n";

  assert(Concept::LeafTreeNode<Node>); // TODO implement other nodes...
  for (std::size_t codim = fem_codim; codim <= GridView::dimension; ++codim) {
    for (const auto& gt : gridView().indexSet().types(codim)) {
      const auto gt_index = GlobalGeometryTypeIndex::index(gt);
      if (fixedSizePerGeometryType()) {
        std::cout << "  " << gt << ", " << blockCount(gt_index) << " \n";
      } else {
        auto gt_begin = std::begin(_gt_entity_offsets) + gt_index;
        auto size = *(gt_begin+1) - *gt_begin;
        for (std::size_t i = 0; i != size; ++i)
          std::cout << "  " << gt << ", " << i << ", " << _entity_dof_offsets[i + *gt_begin] << "\n";
      }
    }
  }
}

template<class Node, class GV, class MS>
typename TopologicAssociativityForestNode<Node,GV,MS>::SizeType
TopologicAssociativityForestNode<Node,GV,MS>::dimension() const noexcept
{
  SizeType dof_count = 0;
  forEachLeafNode(
    node(), [&](auto& leaf, auto path) { dof_count += leaf.blockCount(); });
  return dof_count;
}

template<class Node, class GV, class MS>
template<Concept::MultiIndex CompositionSuffix>
auto TopologicAssociativityForestNode<Node,GV,MS>::containerIndexRange(
  CompositionSuffix comp_suff,
  SizeType gt_index,
  SizeType entity_index) const noexcept
{
  // Note: Multi-index is read Outer->Inner
  // only map known geometry indices
  assert(containsGeometry(gt_index));
  if constexpr (Concept::LeafTreeNode<Node>) {
    // (end of recursion) in case of leaf node.
    // Simply return iota (in form of a multi-index of size 1) from 0 to the block size of this node.
    static_assert(CompositionSuffix::size() == 0);
    auto mae_range = [&](){
      constexpr std::optional static_sz = Node::commonSizePerGeometryType();
      if constexpr (static_sz)
        return range(index_constant<static_sz.value()>());
      else
        return range(blockCount(gt_index, entity_index));
    };
    return transformedRangeView(mae_range(), [](SizeType i){ return TypeTree::treePath(i); });
  } else {
    static_assert(CompositionSuffix::size() > 0);
    const auto child = front(comp_suff);
    // (continue recursion) get container index of the child node.
    const auto cir = node().child(child).containerIndexRange(pop_front(comp_suff), gt_index, entity_index);
    if constexpr (MergingStrategy::Blocked) {
      // blocked merging: simply push front the child index
      return transformedRangeView(std::move(cir), [child](auto ci){ return push_front(ci, child); });
    } else {
      SizeType offset = 0;
      // lexicopgraphic merging: accumulate front the offest of the (child-1)
      if (child != 0) {
        if (fixedSizePerGeometryType()) {
          offset = _gt_dof_offsets[gt_index * node().degree() + child - 1];
        } else {
          const auto index = (_gt_entity_offsets[gt_index] + entity_index) * node().degree() + child - 1;
          offset = _entity_dof_offsets[index];
        }
      }
      return transformedRangeView(std::move(cir), [offset](auto ci){ return accumulate_front(ci, offset); });
    }
  }
}

template<class Node, class GV, class MS>
constexpr auto TopologicAssociativityForestNode<Node,GV,MS>::treesBlocked()
{
  // the blocking structure of a local space is given by the tag of its
  // children
  if constexpr (Concept::LeafTreeNode<Node>) {
    return Node::MergingStrategy::Blocked;
  } else if constexpr (Concept::ArrayTreeNode<Node> ||
                       Concept::VectorTreeNode<Node>) {
    constexpr bool child_blocked = Node::ChildType::treesBlocked();
    return std::integral_constant<bool, child_blocked>{};
  } else if constexpr (Concept::TupleTreeNode<Node>) {
    auto unfold_children = [&](auto... i) {
      constexpr bool any_blocked =
        (TypeTree::template Child<Node, i>::treesBlocked() || ...);
      constexpr bool all_blocked =
        (TypeTree::template Child<Node, i>::treesBlocked() && ...);
      static_assert(all_blocked == any_blocked,
                    "All leaf nodes of of basis grouped "
                    "by entity must have the same blocking requirements");
      return std::integral_constant<bool, any_blocked>{};
    };
    auto indices = std::make_index_sequence<Node::degree()>{};
    return unpackIntegerSequence(unfold_children, indices);
  } else {
    static_assert(Dune::AlwaysFalse<Node>{}, "Not known Node Type");
  }
}

template<class Node, class GV, class MS>
template<Concept::MultiIndex ContainerSuffix>
std::size_t
TopologicAssociativityForestNode<Node,GV,MS>::containerSize(const ContainerSuffix& cs,
                                                         SizeType gt_index,
                                                         SizeType entity_index) const noexcept
{
  // Note: Multi-index is read Inner->Outer
  // transform to reserved multi-index to avoid problems on pop back
  auto rcs = MultiIndex<SizeType, maxContainerDepth()>{ cs };
  // suffix wants the size for this node
  if (rcs.size() == 0)
    return node().blockCount(gt_index, entity_index);

  if constexpr (Concept::LeafTreeNode<Node>) {
    assert(rcs.size() == 1);
    return 0; // Leaf nodes contain no more indices
  } else {

    // helper to return from any child with a dynamic child index
    auto childContainerSize = [&](std::size_t child_i,
                                  auto next_suffix) -> SizeType {
      if constexpr (Concept::ArrayTreeNode<Node> ||
                    Concept::VectorTreeNode<Node>) {
        return node().child(child_i).containerSize(
          next_suffix, gt_index, entity_index);
      } else {
        static_assert(Concept::TupleTreeNode<Node>);
        // at this point we recoverd the index, but there is no way to
        // propagate its static information outside of this function (i.e. a
        // return type that depends on the child index)
        SizeType _size = std::numeric_limits<SizeType>::max();
        // make a loop over all nodes and check which one matches the child
        // index
        forEachChild(this->node(), [&](auto& child, auto i) {
          if (i == child_i)
            _size = child.containerSize(next_suffix, gt_index, entity_index);
        });
        return _size;
      }
    };

    // the next index to find out its size
    auto back_index = back(rcs);
    // task: find child the child node for whom this index corresponds
    if constexpr (MergingStrategy::Blocked) {
      // easy case, the back_index is exactly the index of the child node
      return childContainerSize(back_index, pop_back(rcs));
    } else {
      // here we need to "recover" the child index that describes the
      // back_index (inverse of containerIndexRange operation)
      assert(_gt_used[gt_index]);
      auto dof_begin = std::begin(fixedSizePerGeometryType() ? _gt_dof_offsets : _entity_dof_offsets);
      if (fixedSizePerGeometryType())
        dof_begin += gt_index * node().degree();
      else
        dof_begin += (_gt_entity_offsets[gt_index] + entity_index) * node().degree();
      auto dof_end = dof_begin + node().degree();
      auto dof_it = std::upper_bound(dof_begin, dof_end, back_index);
      auto next = accumulate_back(rcs, SizeType{ 0 });
      if (dof_it != dof_begin) {
        std::advance(dof_it, -1);
        assert(back(cs) >= *dof_it);
        next = accumulate_back(next, -(*dof_it));
      }
      std::size_t child_index = std::distance(dof_begin, dof_it);
      assert(node().degree() > child_index);
      return childContainerSize(child_index, next);
    };
  }
}

template<class Node, class GV, class MS>
void TopologicAssociativityForestNode<Node,GV,MS>::update(GridView grid_view)
{
  forEachNode(node(), [&grid_view](auto& node) {
    node._grid_view = grid_view;
  });
}

template<class Node, class GV, class MS>
void TopologicAssociativityForestNode<Node,GV,MS>::initializeIndices()
{
  updateFixedSizeOrderings();
  if (not fixedSizePerGeometryTypeStatic())
    updateVariableSizeOrderings();

  shareChildenData();
}

template<class Node, class GV, class MS>
auto TopologicAssociativityForestNode<Node,GV,MS>::blockCount(const SizeType gt_index,
                              const SizeType entity_index) const noexcept
{
  if constexpr (Concept::LeafTreeNode<Node>) {
    if constexpr (fixedSizePerGeometryTypeStatic())
      return std::integral_constant<SizeType, Node::commonSizePerGeometryType().value()>();
    else if (fixedSizePerGeometryType()) {
      return blockCount(gt_index);
    } else {
      auto gt_offset = _gt_entity_offsets[gt_index] + entity_index;
      return _entity_dof_offsets[gt_offset];
    }
  } else if constexpr (MergingStrategy::Blocked) {
    return node().degree();
  } else {
    assert(containsGeometry(gt_index));
    if (fixedSizePerGeometryType())
      return SizeType{ blockCount(gt_index) };

    auto gt_offset = _gt_entity_offsets[gt_index] + entity_index;
    const auto degree = node().degree();
    return _entity_dof_offsets[gt_offset * degree + degree - 1];
  }
}

template<class Node, class GV, class MS>
auto TopologicAssociativityForestNode<Node,GV,MS>::blockCount(std::size_t gt_index) const noexcept
{
  assert(fixedSizePerGeometryType());
  if constexpr (Concept::LeafTreeNode<Node>) {
    if constexpr (fixedSizePerGeometryTypeStatic())
      return std::integral_constant<SizeType, Node::commonSizePerGeometryType().value()>();
    else
      return _gt_dof_offsets[gt_index];
  } else if constexpr (MergingStrategy::Blocked) {
    return node().degree();
  } else {
    const auto degree = node().degree();
    return _gt_dof_offsets[gt_index * degree + degree - 1];
  }
}

template<class Node, class GV, class MS>
auto TopologicAssociativityForestNode<Node,GV,MS>::blockCount() const noexcept
{
  if constexpr (MergingStrategy::Blocked and not Concept::LeafTreeNode<Node>) {
    return node().degree();
  } else {
    return _block_count;
  }
}


template<class Node, class GV, class MS>
template<class EntityCodim>
constexpr auto TopologicAssociativityForestNode<Node,GV,MS>::mayContainCodim(EntityCodim entity_codim)
{
  if constexpr (Concept::LeafTreeNode<Node>) {
    constexpr std::size_t entity_dim = GridView::dimension - entity_codim;
    // dimension of the finite element domain (perhaps embedded on sub entities)
    using FEM = typename Node::ProtoBasis::FiniteElementMap;
    constexpr std::size_t fem_dim = FEM::Traits::FiniteElement::Traits::LocalBasisType::Traits::dimDomain;
    if constexpr (entity_dim > fem_dim) {
      // requested dim is higher than the finite element dimension thus not contained
      return std::false_type{};
    } else if constexpr (requires { FEM::hasDOFs(int{}); }) {
      // in this case we can check if a DOF is included or not
      constexpr std::size_t fem_codim = fem_dim - entity_dim;
      constexpr bool has_dofs = FEM::hasDOFs(static_cast<int>(fem_codim));
      return std::integral_constant<bool, has_dofs>{};
    } else {
      return std::true_type{};
    }
  } else if constexpr (Concept::ArrayTreeNode<Node> ||
                       Concept::VectorTreeNode<Node>) {
    return Node::ChildType::mayContainCodim(entity_codim);
  } else if constexpr (Node::isComposite) {
    auto unfold_children = [&](auto... i) {
      constexpr bool has_dofs =
        (TypeTree::template Child<Node, i>::mayContainCodim(entity_codim) || ...);
      return std::integral_constant<bool, has_dofs>{};
    };
    auto indices = std::make_index_sequence<Node::degree()>{};
    return unpackIntegerSequence(unfold_children, indices);
  } else {
    static_assert(Dune::AlwaysFalse<Node>{}, "Not known Node Type");
  }
}

template<class Node, class GV, class MS>
auto constexpr TopologicAssociativityForestNode<Node,GV,MS>::maxCodimCount()
{
  auto sequence = std::make_index_sequence<1 + GridView::dimension>{};

  constexpr std::size_t count = Dune::unpackIntegerSequence(
    [&](auto... codim) {
      constexpr std::size_t one{ 1 }, zero{ 0 };
      return ((TopologicAssociativityForestNode::mayContainCodim(codim) ? one : zero) + ...);
    },
    sequence);
  return std::integral_constant<std::size_t, count>{};
}

template<class Node, class GV, class MS>
void TopologicAssociativityForestNode<Node,GV,MS>::updateFixedSizeOrderings()
{
  const std::size_t dim = GridView::dimension;

  _fixed_size = fixedSizePerGeometryTypeStatic();
  _max_local_coeff_count = 0;
  _block_count = 0;

  if constexpr (fixedSizePerGeometryTypeStatic()) {
    // reset falgs and offsets
    _codim_used.reset();
    const auto gt_count = GlobalGeometryTypeIndex::size(dim);
    _gt_used.assign(gt_count, false);
    std::size_t sz = gt_count * std::max<std::size_t>(1, node().degree());
    std::tie(_gt_dof_offsets_storage, _gt_dof_offsets) = make_span_storage(sz, SizeType{0});
  }

  // fill out flags and offsets depending on the node type
  if constexpr (Concept::LeafTreeNode<Node>) {

    using FEM = typename Node::ProtoBasis::FiniteElementMap;
    constexpr std::size_t fem_dim = FEM::Traits::FiniteElement::Traits::LocalBasisType::Traits::dimDomain;
    constexpr std::size_t fem_codim = GridView::dimension - fem_dim;

    if constexpr (fixedSizePerGeometryTypeStatic()) {
      for (std::size_t codim = fem_codim; codim <= GridView::dimension; ++codim) {
        for (const auto& gt : gridView().indexSet().types(codim)) {
          SizeType size = node().protoBasis().finiteElementMap().size(gt);
          const auto gt_index = GlobalGeometryTypeIndex::index(gt);
          _gt_dof_offsets[gt_index] = size;
          _gt_used[gt_index] = size > 0;
          _block_count += size * gridView().size(gt);
          assert(codim == dim - gt.dim());
          _codim_used[codim] = _codim_used[codim] or (size > 0);
        }
      }
      // collect max entity sides on fem dimension for an entity of codimension 0
      int max_sub_entities = 0;
      for (const auto& gt : gridView().indexSet().types(0)) {
        using Dune::referenceElement;
        auto ref_el = referenceElement<double, GridView::dimension>(gt);
        max_sub_entities = std::max(max_sub_entities, ref_el.size(GridView::dimension - fem_dim));
      }
      node().setMaxSubEntities(max_sub_entities);
      _max_local_coeff_count = max_sub_entities * node().protoBasis().finiteElementMap().maxLocalSize();
    }
  } else {
    forEachChild(this->node(), [&](auto& child, auto i) {
      // first, set up child gt collection
      child.updateFixedSizeOrderings();
      // then, accumulate child results to this node
      if constexpr (fixedSizePerGeometryTypeStatic()) {
        // this node can only be fixed size if child is also fixed size
        assert(child.fixedSizePerGeometryTypeStatic());

        // properties contained in child nodes are also contained here
        for (std::size_t codim = 0; codim <= dim; ++codim)
          _codim_used[codim] =
            _codim_used[codim] or child.containsCodim(codim);

        for (std::size_t gt = 0; gt < _gt_used.size(); ++gt)
          _gt_used[gt] = _gt_used[gt] or child.containsGeometry(gt);

        _max_local_coeff_count += child.maxLocalCount();

        if (not MergingStrategy::Blocked)
          _block_count += child.blockCount();

        // get size of child nodes
        for (std::size_t gt = 0; gt < _gt_used.size(); ++gt)
          _gt_dof_offsets[gt * node().degree() + i] = child.blockCount(gt);
      }
    });
  }

  if constexpr (fixedSizePerGeometryTypeStatic()) {
    // finally, convert child gt sizes into offsets
    auto it = std::begin(_gt_dof_offsets);
    const auto advance = std::max<std::size_t>(1, node().degree());
    while (it != std::end(_gt_dof_offsets))
      it = std::partial_sum(it, it + advance, it);
  }
}

template<class Node, class GV, class MS>
void TopologicAssociativityForestNode<Node,GV,MS>::allocateVariableSizeOrdering()
{
  static_assert(not fixedSizePerGeometryTypeStatic());
  _codim_used.reset();
  const auto gt_count = GlobalGeometryTypeIndex::size(GridView::dimension);
  std::size_t sz = gt_count * std::max<std::size_t>(1, node().degree());

  _gt_used.assign(gt_count, false);
  std::tie(_gt_entity_offsets_storage, _gt_entity_offsets) = make_span_storage(gt_count + 1, SizeType{0});
  std::tie(_gt_dof_offsets_storage, _gt_dof_offsets) = make_span_storage(sz, GT_UNUSED);
}

template<class Node, class GV, class MS>
template<class Entity>
void TopologicAssociativityForestNode<Node,GV,MS>::collectLeafGeometryTypes(const Entity& entity)
{
  static_assert(not fixedSizePerGeometryTypeStatic());
  static_assert(Concept::LeafTreeNode<Node>);
  static_assert(Dune::Concept::EntityExtended<Entity>);
  assert(not fixedSizePerGeometryType());

  using FEM = typename Node::ProtoBasis::FiniteElementMap;
  constexpr std::size_t fem_dim = FEM::Traits::FiniteElement::Traits::LocalBasisType::Traits::dimDomain;
  constexpr std::size_t fem_codim = GridView::dimension - fem_dim;

  const FEM& fem = node().protoBasis().finiteElementMap();
  std::size_t max_coeff_count = 0;
  for (const auto& sub_entity : subEntities(entity, Dune::Codim<fem_codim>{})) {
    const auto& finite_element = fem.find(sub_entity);
    using FEM = typename Node::ProtoBasis::FiniteElementMap;
    using FESwitch = FiniteElementInterfaceSwitch<typename FEM::Traits::FiniteElement>;
    const auto& coeffs = FESwitch::coefficients(finite_element);
    max_coeff_count += coeffs.size();

    const auto& ref_el = referenceElement(sub_entity.geometry());
    for (std::size_t i = 0; i < coeffs.size(); ++i) {
      const auto& key = coeffs.localKey(i);
      auto gt_index = GlobalGeometryTypeIndex::index(ref_el.type(key.subEntity(), key.codim()));
      _gt_used[gt_index] = true;
      _codim_used.set(fem_codim + key.codim());
    }
  }
  _max_local_coeff_count = std::max<std::size_t>(_max_local_coeff_count, max_coeff_count);
  node().setMaxSubEntities(std::max<int>(node().maxSubEntities(), entity.subEntities(fem_codim)));
}

template<class Node, class GV, class MS>
void TopologicAssociativityForestNode<Node,GV,MS>::collectGeometryTypes()
{
  _fixed_size_possible = true;

  if constexpr (not Concept::LeafTreeNode<Node>) {
    forEachChild(this->node(), [&](auto& child, auto path) {
      child.collectGeometryTypes();

      if constexpr (not fixedSizePerGeometryTypeStatic()) {
        // properties contained in child nodes are also contained here
        for (std::size_t codim = 0; codim <= GridView::dimension; ++codim)
          _codim_used[codim] =
            _codim_used[codim] or child.containsCodim(codim);

        for (std::size_t gt = 0; gt < _gt_used.size(); ++gt)
          _gt_used[gt] = _gt_used[gt] or child.containsGeometry(gt);
      }
    });
  }

  // create offset of indices for contained geometry types
  if constexpr (not fixedSizePerGeometryTypeStatic()) {
    for (std::size_t codim = 0; codim <= GridView::dimension; ++codim) {
      for (const auto& gt : gridView().indexSet().types(codim)) {
        const auto gt_index = GlobalGeometryTypeIndex::index(gt);
        if (containsGeometry(gt_index))
          _gt_entity_offsets[gt_index + 1] = gridView().indexSet().size(gt);
      }
      std::partial_sum(std::begin(_gt_entity_offsets),
                        std::end(_gt_entity_offsets),
                        std::begin(_gt_entity_offsets));
      std::size_t sz = _gt_entity_offsets.back() * std::max<std::size_t>(node().degree(), 1);
      std::tie(_entity_dof_offsets_storage, _entity_dof_offsets) = make_span_storage(sz, SizeType{0});
    }
  }
}

template<class Node, class GV, class MS>
template<class Entity>
void TopologicAssociativityForestNode<Node,GV,MS>::collectEntitySizes(const Entity& entity, std::vector<SizeType>& gt_cache)
{
  static_assert(not fixedSizePerGeometryTypeStatic());
  static_assert(Concept::LeafTreeNode<Node>);
  if (_fixed_size_possible)
    std::fill(gt_cache.begin(), gt_cache.end(), GT_UNUSED);

  using FEM = typename Node::ProtoBasis::FiniteElementMap;
  constexpr std::size_t fem_dim = FEM::Traits::FiniteElement::Traits::LocalBasisType::Traits::dimDomain;
  constexpr std::size_t fem_codim = GridView::dimension - fem_dim;

  const FEM& fem = node().protoBasis().finiteElementMap();
  for (std::size_t s = 0; s != entity.subEntities(fem_codim); ++s) {
    const auto& sub_entity = [&]{
      if constexpr (fem_codim == 0)
        return entity;
      else
        return entity.template subEntity<fem_codim>(s);
    }();

    const auto& finite_element = fem.find(sub_entity);
    if (finite_element.type() != entity.type())
      DUNE_THROW(RangeError, "Dune::GeometryType of the local finite element and entity do not match!");
    using FEM = typename Node::ProtoBasis::FiniteElementMap;
    using FESwitch =
      FiniteElementInterfaceSwitch<typename FEM::Traits::FiniteElement>;
    const auto& coeffs = FESwitch::coefficients(finite_element);

    const auto& ref_el = referenceElement(sub_entity.geometry());
    for (std::size_t dof = 0; dof != coeffs.size(); ++dof) {
      const LocalKey& key = coeffs.localKey(dof);
      const SizeType gt_index = GlobalGeometryTypeIndex::index(ref_el.type(key.subEntity(), key.codim()));
      const SizeType entity_index = gridView().indexSet().subIndex(sub_entity, key.subEntity(), fem_codim + key.codim());
      const SizeType index = _gt_entity_offsets[gt_index] + entity_index;
      gt_cache[gt_index] = _entity_dof_offsets[index] = std::max<SizeType>(_entity_dof_offsets[index], key.index() + 1);
    }
  }

  // as long as we haven't discarded possible fixed size, we try to find
  // out if the seen geometry types have fixed size
  if (_fixed_size_possible) {
    for (std::size_t i = 0; i < gt_cache.size(); ++i) {
      // update unused entries
      if (_gt_dof_offsets[i] == GT_UNUSED)
        _gt_dof_offsets[i] = gt_cache[i];
      // if cache does not match global gt sizes, we need to discard fixed
      // size computations
      if (_gt_dof_offsets[i] != gt_cache[i]) {
        _fixed_size_possible = false;
        break;
      }
    }
  }
}

template<class Node, class GV, class MS>
void TopologicAssociativityForestNode<Node,GV,MS>::accumulateEntityOffsets()
{
  _block_count = 0;
  if constexpr (Concept::LeafTreeNode<Node>) {
    // if we did't discard fixed size by this point, we can use the
    // fixed size geometry type sizes
    if (_fixed_size_possible) {
      _entity_dof_offsets_storage = nullptr; // discard individual entity sizes
      _entity_dof_offsets = {};
      _fixed_size = true;
    }
    // mask out GT_UNUSED for geometry types that really weren't used
    for (std::size_t codim = 0; codim <= GridView::dimension; ++codim) {
      for (const auto& gt : gridView().indexSet().types(codim)) {
        auto& size = _gt_dof_offsets[GlobalGeometryTypeIndex::index(gt)];
        if (size == GT_UNUSED)
          size = 0;
        if (_fixed_size)
          _block_count += size * gridView().size(gt);
      }
    }
    if (not _fixed_size)
      _block_count = std::accumulate(std::begin(_entity_dof_offsets), std::end(_entity_dof_offsets), 0);
  } else {
    // update node properties
    _fixed_size_possible = true;
    forEachChild(this->node(), [&](auto& child, auto path) {
      // update sub-tree
      child.accumulateEntityOffsets();
      _fixed_size_possible &= child.fixedSizePerGeometryType();
      _max_local_coeff_count += child.maxLocalCount();
    });

    const std::size_t dim = GridView::dimension;
    const std::size_t gt_count = GlobalGeometryTypeIndex::size(dim);
    if (_fixed_size_possible) {
      // we need to update gt sizes from children and convert them to offsets
      forEachChild(this->node(), [&](auto& child, auto i) {
        for (std::size_t codim = 0; codim <= GridView::dimension; ++codim) {
          for (const auto& gt : gridView().indexSet().types(codim)) {
            const auto gt_index = GlobalGeometryTypeIndex::index(gt);
            const auto gt_offset = gt_index * node().degree() + i;
            const auto cb_count = child.blockCount(gt_index);
            _gt_dof_offsets[gt_offset] = cb_count;
            _block_count += cb_count * gridView().size(gt);
            if (i != 0)
              _gt_dof_offsets[gt_offset] = _gt_dof_offsets[gt_offset - 1] + cb_count;
          }
        }
      });

      _fixed_size = true;
    } else {
      // no fixed size was possible, save offsets for each entity:
      //   for every entity we already have block count,
      //   then, we just need to carry such count to the next entity value
      SizeType index = 0;
      for (SizeType gt = 0; gt < gt_count; ++gt) {
        if (not containsGeometry(gt))
          continue;
        assert(_gt_entity_offsets[gt] <= _gt_entity_offsets[gt + 1]);
        const SizeType entity_count =
          _gt_entity_offsets[gt + 1] - _gt_entity_offsets[gt];
        for (SizeType e_index = 0; e_index < entity_count; ++e_index) {
          SizeType carry = 0;
          forEachChild(this->node(), [&](auto& child, auto path) {
            carry += child.blockCount(gt, e_index);
            _entity_dof_offsets[index++] = carry;
          });
          _block_count += MergingStrategy::Blocked ? (carry != 0) : carry;
        }
      }
    }
  }
}

template<class Node, class GV, class MS>
void TopologicAssociativityForestNode<Node,GV,MS>::updateVariableSizeOrderings()
{

  forEachNode(node(), []<class T>(T& node, auto path) {
    if constexpr (not T::fixedSizePerGeometryTypeStatic())
      node.allocateVariableSizeOrdering();
  });

  for (const auto& entity : elements(gridView())) {
    forEachLeafNode(node(), [&]<class T>(T& leaf, auto path) {
      if constexpr (not T::fixedSizePerGeometryTypeStatic())
        leaf.collectLeafGeometryTypes(entity);
    });
  }

  collectGeometryTypes();

  { // construct cache outside entity collection to avoid reallocation
    const std::size_t dim = GridView::dimension;
    std::vector<SizeType> gt_cache(GlobalGeometryTypeIndex::size(dim), 0);

    for (const auto& entity : elements(gridView())) {
      forEachLeafNode(node(), [&]<class T>(T& leaf, auto path) {
        if constexpr (not T::fixedSizePerGeometryTypeStatic())
          leaf.collectEntitySizes(entity, gt_cache);
      });
    }
  }
  accumulateEntityOffsets();
}

template<class Node, class GV, class MS>
void TopologicAssociativityForestNode<Node,GV,MS>::shareChildenData() {
  // in case of vector space (same underlying function space), enable sharing states in children nodes
  if constexpr (not Concept::LeafTreeNode<Node>) {
    // compare other nodes to the first one
    const auto& ref_node = node().child(Dune::Indices::_0);
    PDELab::forEachChild(node(), [&](auto& child, auto i) {
      child.shareChildenData();
      if (i > 0)
        child.useDataFromSibling(ref_node);
    });
  }
}



template<class Node, class GV, class MS>
void TopologicAssociativityForestNode<Node,GV,MS>::useDataFromSibling(const auto& other) {
  if (_gt_dof_offsets_storage and std::equal(_gt_dof_offsets.begin(), _gt_dof_offsets.end(), other._gt_dof_offsets.begin(), other._gt_dof_offsets.end())) {
    _gt_dof_offsets_storage = other._gt_dof_offsets_storage;
    _gt_dof_offsets = other._gt_dof_offsets;
  }

  if (_gt_entity_offsets_storage and std::equal(_gt_entity_offsets.begin(), _gt_entity_offsets.end(), other._gt_entity_offsets.begin(), other._gt_entity_offsets.end())) {
    _gt_entity_offsets_storage = other._gt_entity_offsets_storage;
    _gt_entity_offsets = other._gt_entity_offsets;
  }

  if (_entity_dof_offsets_storage and std::equal(_entity_dof_offsets.begin(), _entity_dof_offsets.end(), other._entity_dof_offsets.begin(), other._entity_dof_offsets.end())) {
    _entity_dof_offsets_storage = other._entity_dof_offsets_storage;
    _entity_dof_offsets = other._entity_dof_offsets;
  }
}

} // namespace Dune::PDELab::Impl

#endif // DUNE_PDELAB_BASIS_TOPOLOGIC_ASSOCIATIVITY_FOREST_NODE_HH
