#ifndef DUNE_PDELAB_BASIS_ORDERING_ENTITY_HH
#define DUNE_PDELAB_BASIS_ORDERING_ENTITY_HH

// #include <dune/pdelab/concepts/multiindex.hh>
// #include <dune/assembler/concepts/treenode.hh>
// #include <dune/assembler/concepts/indexable.hh>

// #include <dune/assembler/common/reservedmultiindex.hh>
// #include <dune/assembler/common/tree_traversal.hh>
// #include <dune/assembler/common/container_entry.hh>

// #include <dune/assembler/space/concept.hh>
// #include <dune/assembler/space/merging_strategy.hh>

// #include <dune/typetree/compositenode.hh>
// #include <dune/typetree/dynamicpowernode.hh>
// #include <dune/typetree/leafnode.hh>
// #include <dune/typetree/powernode.hh>
// #include <dune/typetree/traversal.hh>

// #include <dune/localfunctions/common/interfaceswitch.hh>
// #include <dune/localfunctions/common/localkey.hh>

// #include <dune/geometry/type.hh>
// #include <dune/geometry/typeindex.hh>
// #include <dune/geometry/referenceelements.hh>

// #include <vector>
// #include <span>
// #include <optional>
// #include <numeric>

// #ifndef DUNE_ASSEMBLER_FAST_DG_OPTIMIZATION
// #define DUNE_ASSEMBLER_FAST_DG_OPTIMIZATION 1
// #endif

// namespace Dune::Assembler::Impl {

// /**
//  * @brief Ordering of entity degrees of freedom
//  * This class is in charge to map a degree of freedom within an entity to a
//  * multi-index. Such mapping is injective with respect to a specific entity,
//  * in particular, the resulting multi-indices start from 0. For example, an
//  * entity with 3 degrees of freedom may be mapped into (0), (1), and (2),
//  * or into (0,0), (1,0), and (1,1) for a ordering of two children and blocked
//  * structure.
//  *
//  * The mapping is constructed in a bottom-up fashion.
//  * First, the leaf node extract an ordering based on a local finite element
//  * for each entity (see LocalCoefficients and LocalKey objects from
//  * dune-localfunctions). The resulting ordering for leaf nodes is guarnteed to
//  * be consequitive with 0-based indexation, i.e. an entity that has 3 DOFs
//  * associated with it, will alywas map their local keys into (0), (1) and (2).
//  * This requirement is important in order to provide fast mappings for DG
//  * spaces! Second, a parent node compose its children indices with respect to a
//  * merging strategy. For example, a blocked strategy consists on prefixing the
//  * child index into the child indices.
//  *
//  * In particular, the complexity on the implementation of this object comes
//  * from the fact that the offsets for every entity in an entity set are stored
//  * as contiguously as possible and using many information at compile time
//  * whenever possible.
//  *
//  * The most important part to understand on this class are the
//  * `firstContainerIndex` and `containerSize` methods. See their documentation
//  * first. All the rest of this class turns around the data structures used in
//  * there.
//  *
//  * This local map is the used to construct a global map that takes into account the
//  * whole grid, in other words, a set of maps where each entity maps to a uniquely
//  * different multi-index (which is the countrary of this class where each
//  * entity is individually mapped and the result is not necessarily unique)
//  * @see EntitySetOrderingNode.
//  *
//  * The mappings produced by this class is almost dense. The cases where the
//  * map is not dense is where blocked structure induces a multi-index whose
//  * suffix has a 0-size range on the last index. This happens when there is at
//  * least one blocking merging strategy within the tree and the finite elements
//  * of the different leaf nodes cover different codimensions. An example of
//  * this case is taylorhood elements of degree 1 where all nodes are entity
//  * ordered with blocked merged strategy: The root node will provide the whole
//  * tree suffix to the multi-index (because of the blocked strategy) but the
//  * children node corresponding to the pressure element have no DOFs in the
//  * facets of the elements.
//  *
//  * @note Order of multi-indices: The indices generated by this map follow a
//  * top to bottom ordering, meanig that lefttmost indices indicate a tree-path
//  * from the upper part of a tree of indices, while rightmost indices indicate
//  * lower parts on the tree. This is consistent with dune-functions and countrary
//  * to PDELab orderings.
//  *
//  * @todo Compile-time check whether dense ordering is guaranteed
//  * @todo Avoid repeated update on vector spaces_gt_dof_offsets
//  * @todo Create an abrstraction for the offset vectors. Raw managment of them
//  * has proven to be error prone and hard to mantain.
//  *
//  * @tparam Node   A typetree node using that inherits this class (Barton–Nackman
//  * trick)
//  * @tparam MS     A merging strategy
//  */
// template<class Node, class MS>
// class EntityOrderingNode
// {
//   // Notice that by this point `Node` is an incomplete type because it will only
//   // be completed after inheriting from this class (Barton–Nackman trick)
//   // Therefore, we can only inquiry its contents after completion, which
//   // is why we only deduce types on functions and not in the class scope.

//   // the type to export multi-indices
//   using SizeType = typename MS::SizeType;
//   // the type for bitset information of codimensions used
//   using CodimFlag = typename MS::CodimFlag;
//   // the type for entitysets
//   using EntitySet = typename MS::EntitySet;
//   // a key value to identify geometry types that are not mapped by this class
//   static constexpr SizeType GT_UNUSED = std::numeric_limits<SizeType>::max();

//   // We share private methods with other nodes of the same kind. This allows
//   // to have algorithms in one templated class and still keep internals
//   // encapsulated to the outside.
//   // But with great power comes great responsability:
//   //   DO NOT MODIFY OTHER NODE PRIVATE MEMBERS!
//   //   Otherwise code becomes -more- unmaintainable and harder to reason about
//   //   instead create a function that describes the performed action
//   template<class Node_, class MS_>
//   friend class EntityOrderingNode;

// public:
//   using MergingStrategy = MS;

//   EntityOrderingNode(const MergingStrategy& merging_strategy)
//     : _merging_strategy{ merging_strategy }
//     , _fixed_size{ prioryFixedSize() }
//     , _fixed_size_possible{ true }
//   {
//     // all the entity sets below this node shall be the equal to each other
//     if constexpr (std::equality_comparable<EntitySet>)
//       forEachLeafNode(node(), [&](auto& leaf, auto path) {
//         assert(entitySet() == leaf.entitySet());
//       });

//     // in case of vector space (same underlying discrete-function-space), enable
//     // sharing states in children nodes
//     if constexpr (Concept::ArrayTreeNode<Node> ||
//                   Concept::VectorTreeNode<Node>) {
//       if (node().degree() > 0) {
//         // compare other nodes to the first one
//         const auto& model_node = node().child(0);
//         bool vector_space = true;
//         forEachLeafNode(model_node, [&](auto& leaf_node, auto& path) {
//           for (std::size_t i = 1; i < node().degree(); ++i)
//             vector_space &=
//               (leaf_node.space() ==
//                TypeTree::child(node().child(i), path).space());
//         });
//         // if discrete-function-space was equal everywhere, reuse storage of
//         // children
//         if (vector_space)
//           for (std::size_t i = 1; i < node().degree(); ++i)
//             node().childStorage(i) = node().childStorage(0);
//       }
//     }
//   }

//   EntityOrderingNode(const EntityOrderingNode&) = delete;
//   EntityOrderingNode(EntityOrderingNode&&) = default;

//   // Check if all leaf nodes have the same fixed DOF size per geometry type at compile time
//   [[nodiscard]] static consteval auto prioryFixedSize()
//   {
//     if constexpr (Concept::LeafTreeNode<Node>) {
//       // base case: query information from finite element map
//       return Node::commonSizePerGeometryType().has_value();
//     } else if constexpr (Concept::ArrayTreeNode<Node> ||
//                          Concept::VectorTreeNode<Node>) {
//       // all children have the same type so we inherit their fixed size
//       return Node::ChildType::prioryFixedSize();
//     } else {
//       // make a conjunction of all the children types
//       static_assert(Node::isComposite);
//       auto unfold_children = [&](auto... i) {
//         constexpr bool all_fixed_size =
//           (TypeTree::template Child<Node, i>::prioryFixedSize() && ...);
//         return std::integral_constant<bool, all_fixed_size>{};
//       };
//       auto indices = std::make_index_sequence<Node::degree()>{};
//       return unpackIntegerSequence(unfold_children, indices);
//     }
//   }

//   // Gives the maximum size of a prefix produced by this ordering
//   [[nodiscard]] static consteval std::size_t maxContainerDepth()
//   {
//     if constexpr (Concept::LeafTreeNode<Node>) {
//       return 1;
//     } else {
//       auto child_depth = [&]() {
//         if constexpr (Concept::ArrayTreeNode<Node> ||
//                       Concept::VectorTreeNode<Node>) {
//           return Node::ChildType::maxContainerDepth();
//         } else {
//           static_assert(Node::isComposite);
//           return unpackIntegerSequence(
//             [](auto... i) {
//               return std::max({
//                 TypeTree::template Child<Node, i>::maxContainerDepth()...});
//             },
//             std::make_index_sequence<Node::degree()>{});
//         }
//       }();
//       if constexpr (containerBlocked())
//         return child_depth + 1;
//       else
//         return child_depth;
//     }
//   }

//   // Check if this ordering has fixed DOF size per geometry type
//   [[nodiscard]] auto fixedSize() const noexcept
//   {
//     if constexpr (prioryFixedSize())
//       return std::true_type{};
//     else
//       return _fixed_size;
//   }

//   // Entity set of the ordering
//   [[nodiscard]] const auto& entitySet() const noexcept
//   {
//     return _merging_strategy.entitySet();
//   }

//   // Entity set of the ordering
//   [[nodiscard]] auto& entitySet() noexcept
//   {
//     return _merging_strategy.entitySet();
//   }

//   // Check if a given geometry type is mapped to multi-indices within this map
//   [[nodiscard]] bool containsGeometry(SizeType gt_index) const noexcept
//   {
//     return _gt_used[gt_index];
//   }

//   // Check if a given geometry type is mapped to multi-indices within this map
//   [[nodiscard]] bool containsGeometry(const GeometryType& gt) const noexcept
//   {
//     return containsGeometry(GlobalGeometryTypeIndex::index(gt));
//   }

//   // Check if a given codimension is mapped to multi-indices within this map
//   [[nodiscard]] bool containsCodim(SizeType codim) const noexcept
//   {
//     return codimClosure().test(codim);
//   }

//   // Gives a bitset of the codimenions that this class is able to map
//   [[nodiscard]] CodimFlag codimClosure() const noexcept
//   {
//     assert(maxCodimCount() >= _codim_used.count());
//     return _codim_used;
//   }

//   // Check if DOFs only exist in one codimension
//   //! @note This feature is really important. If true, all the multi-indices
//   // can be constructed from the container index suffix and the block count of
//   // a given tree (i.e. no need of local keys of the reference local element).
//   [[nodiscard]] auto singleCodim() const noexcept
//   {
//     if constexpr (maxCodimCount() == 1)
//       return std::true_type{};
//     else
//       return (_codim_used.count() == 1);
//   }

//   // Check if DOFs are only attached to the volume part of the entities.
//   // If true, it should hint to DG and FV spaces.
//   [[nodiscard]] auto disjointCodimClosure() const noexcept
//   {
//     if constexpr (maxCodimCount() == 1)
//       return std::integral_constant<bool, mayContainCodim(Indices::_0)>{};
//     else
//       return (_codim_used.count() == 1 and _codim_used[0]);
//   }

//   // Maximum number of coefficients that may be associated to a local space
//   [[nodiscard]] SizeType maxLocalCount() const noexcept
//   {
//     return _max_local_coeff_count;
//   }

//   // Number of blocks associated to a given entity
//   [[nodiscard]] auto blockCount(const SizeType gt_index,
//                                 const SizeType entity_index) const noexcept
//   {
//     if constexpr (containerBlocked()) {
//       static_assert(not Concept::LeafTreeNode<Node>);
//       return node().degree();
//     } else {
//       assert(containsGeometry(gt_index));
//       if (fixedSize())
//         return SizeType{ blockCount(gt_index) };

//       if constexpr (Concept::LeafTreeNode<Node>) {
//         return (*_entity_dof_offsets)[((*_gt_entity_offsets)[gt_index] +
//                                        entity_index)];
//       } else {
//         const auto degree = node().degree();
//         return (*_entity_dof_offsets)[((*_gt_entity_offsets)[gt_index] +
//                                        entity_index) *
//                                         degree +
//                                       degree - 1];
//       }
//     }
//   }

//   // number of blocks associated to a given entity (fixed size version)
//   [[nodiscard]] auto blockCount(std::size_t gt_index) const noexcept
//   {
//     assert(fixedSize());
//     if constexpr (containerBlocked()) {
//       static_assert(not Concept::LeafTreeNode<Node>);
//       return node().degree();
//     } else {
//       if constexpr (Concept::LeafTreeNode<Node>) {
//         return (*_gt_dof_offsets)[gt_index];
//       } else {
//         const auto degree = node().degree();
//         return (*_gt_dof_offsets)[gt_index * degree + degree - 1];
//       }
//     }
//   }

//   // print offsets to debug orderings...
//   void debugInfo() const {
//     using FEM = typename Node::Space::Traits::FiniteElementMap;
//     constexpr std::size_t fem_dim = FEM::Traits::FiniteElement::Traits::LocalBasisType::Traits::dimDomain;
//     constexpr std::size_t fem_codim = EntitySet::dimension - fem_dim;

//     std::cout << "Fixed Size per Geometry Type: " << bool(fixedSize()) << "\n";
//     std::cout << "Blocked: " << bool(containerBlocked()) << "\n";
//     if (fixedSize())
//       std::cout << "  # Geometry Type, DOF Count\n";
//     else
//       std::cout << "  # Geometry Type, Entity Index, DOF Count ==\n";

//     assert(Concept::LeafTreeNode<Node>); // TODO implement other nodes...
//     for (std::size_t codim = fem_codim; codim <= EntitySet::dimension; ++codim) {
//       for (const auto& gt : entitySet().indexSet().types(codim)) {
//         const auto gt_index = GlobalGeometryTypeIndex::index(gt);
//         if (fixedSize()) {
//           std::cout << "  " << gt << ", " << blockCount(gt_index) << " \n";
//         } else {
//           auto gt_begin = begin(*_gt_entity_offsets) + gt_index;
//           auto size = *(gt_begin+1) - *gt_begin;
//           for (std::size_t i = 0; i != size; ++i)
//             std::cout << "  " << gt << ", " << i << ", " << (*_entity_dof_offsets)[i + *gt_begin] << "\n";
//         }
//       }
//     }
//   }


//   // total number of blocks for this node on all entities
//   [[nodiscard]] auto blockCount() const noexcept
//   {
//     if constexpr (containerBlocked()) {
//       static_assert(not Concept::LeafTreeNode<Node>);
//       return node().degree();
//     } else {
//       return _block_count;
//     }
//   }

//   // counts the number of blocks in the leaf nodes
//   [[nodiscard]] SizeType dimension() const noexcept
//   {
//     SizeType dof_count = 0;
//     forEachLeafNode(
//       node(), [&](auto& leaf, auto path) { dof_count += leaf.blockCount(); });
//     return dof_count;
//   }

//   /**
//    * @brief Gives a container prefix (Outer2Inner) for a particular entity and leaf node of the
//    * tree. The resulting multi-index suffix contains the mapping for the first
//    * DOF on the leaf node and entity. Due to the guarantees of this class,
//    * this is enough information to form all of the other DOFs associated for
//    * this entity. In particular, is only necessary to accumulate front the
//    * local key of the finite element in order to obtain a desired container
//    * index.
//    * @note If disjointCodimClosure() is true, the whole range of indices for
//    * this entity may be obtained by accumulating back in range of
//    * [ 0, blockCount(gt_index, entity_index) ).
//    *
//    * @tparam CompositionSuffix      Type for a treepath (typicaly MultiIndex)
//    * @param comp_suff               Path to the required leaf node
//    * @param gt_index                Index of the geometry type
//    * @param entity_index            Index of the entity
//    * @return Concept::MultiIndex    A Outer2Inner prefix to the first container multi-index
//    */
//   template<Concept::MultiIndex CompositionSuffix>
//   [[nodiscard]] Concept::MultiIndex auto firstContainerIndex(
//     CompositionSuffix comp_suff,
//     SizeType gt_index,
//     SizeType entity_index) const noexcept
//   {
//     // Note: Multi-index is read Outer->Inner
//     // only map known geometry indices
//     assert(containsGeometry(gt_index));
//     if constexpr (Concept::LeafTreeNode<Node>) {
//       // (end of recursion) in case of leaf node. The fist multi-index is
//       // guaranteed to be (0)
//       static_assert(CompositionSuffix::size() == 0);
//       return multiIndex(SizeType{ 0 });
//     } else {
//       static_assert(CompositionSuffix::size() > 0);
//       const auto child = front(comp_suff);
//       // (continue recursion) get container index of the child node.
//       const auto cont_prefix = node().child(child).firstContainerIndex(
//         pop_front(comp_suff), gt_index, entity_index);
//       if constexpr (containerBlocked()) {
//         // blocked merging: simply push front the child index
//         return push_front(cont_prefix, child);
//       } else {
//         SizeType offset = 0;
//         // lexicopgraphic merging: accumulate front the offest of the (child-1)
//         if (child != 0) {
//           if (fixedSize()) {
//             offset = (*_gt_dof_offsets)[gt_index * node().degree() + child - 1];
//           } else {
//             const auto index =
//               ((*_gt_entity_offsets)[gt_index] + entity_index) *
//                 node().degree() +
//               child - 1;
//             offset = (*_entity_dof_offsets)[index];
//           }
//         }
//         return accumulate_front(cont_prefix, offset);
//       }
//     }
//   }

//   // Check if the resulting container is blocked at this node level
//   [[nodiscard]] static constexpr auto containerBlocked()
//   {
//     // the blocking structure of a local space is given by the tag of its
//     // children
//     if constexpr (Concept::LeafTreeNode<Node>) {
//       return std::false_type{};
//     } else if constexpr (Concept::ArrayTreeNode<Node> ||
//                          Concept::VectorTreeNode<Node>) {
//       constexpr bool child_blocked = Node::ChildType::MergingStrategy::Blocked;
//       return std::integral_constant<bool, child_blocked>{};
//     } else if constexpr (Concept::TupleTreeNode<Node>) {
//       auto unfold_children = [&](auto... i) {
//         constexpr bool any_blocked =
//           (TypeTree::template Child<Node, i>::MergingStrategy::Blocked || ...);
//         constexpr bool all_blocked =
//           (TypeTree::template Child<Node, i>::MergingStrategy::Blocked && ...);
//         static_assert(all_blocked == any_blocked,
//                       "All static children of a Space grouped "
//                       "by entity must have the same blocking requirements");
//         return std::integral_constant<bool, any_blocked>{};
//       };
//       auto indices = std::make_index_sequence<Node::degree()>{};
//       return unpackIntegerSequence(unfold_children, indices);
//     } else {
//       static_assert(Dune::AlwaysFalse<Node>{}, "Not known Node Type");
//     }
//   }

//   /**
//    * @brief Gives the total number of indices for any suffix of the mapped
//    * multi-indices
//    * @details Any suffix of a container index generated by this object
//    * (constructed from `firstContainerIndex`) indices a size. Such size refers
//    * to the range of suffixes on the next level of multi-indices. For example,
//    * if a node tree is able to generate the following Inner2Outer multi-indices
//    * for a given entity (0,0,0), (0,1,0), ..., (0,10,0), then the suffix (-,-,0)
//    * induces a size of 11 while (-,0,0), (-,1,0), etc. induce all a size of 1.
//    *
//    * @tparam ContainerSuffix  The type of a sufix (typically a
//    * ReservedMultiIndex)
//    * @param cs                A suffix of a Outer2Inner multi-index contained by this map
//    * @param gt_index          Index of the geometry type
//    * @param entity_index      Index of the entity
//    * @return std::size_t      The size induced by the multi-index suffix
//    */
//   template<Concept::MultiIndex ContainerSuffix>
//   [[nodiscard]] std::size_t containerSize(const ContainerSuffix& cs,
//                                           SizeType gt_index,
//                                           SizeType entity_index) const noexcept
//   {
//     // Note: Multi-index is read Inner->Outer
//     // transform to reserved multi-index to avoid problems on pop back
//     auto rcs = ReservedMultiIndex<SizeType, maxContainerDepth()>{ cs };
//     // suffix wants the size for this node
//     if (rcs.size() == 0)
//       return node().blockCount(gt_index, entity_index);

//     if constexpr (Concept::LeafTreeNode<Node>) {
//       assert(rcs.size() == 1);
//       return 0; // Leaf nodes contain no more indices
//     } else {

//       // helper to return from any child with a dynamic child index
//       auto childContainerSize = [&](std::size_t child_i,
//                                     auto next_suffix) -> SizeType {
//         if constexpr (Concept::ArrayTreeNode<Node> ||
//                       Concept::VectorTreeNode<Node>) {
//           return node().child(child_i).containerSize(
//             next_suffix, gt_index, entity_index);
//         } else {
//           static_assert(Concept::TupleTreeNode<Node>);
//           // at this point we recoverd the index, but there is no way to
//           // propagate its static information outside of this function (i.e. a
//           // return type that depends on the child index)
//           SizeType _size = std::numeric_limits<SizeType>::max();
//           // make a loop over all nodes and check which one matches the child
//           // index
//           forEach(node(), [&](auto& child, auto i) {
//             if (i == child_i)
//               _size = child.containerSize(next_suffix, gt_index, entity_index);
//           });
//           return _size;
//         }
//       };

//       // the next index to find out its size
//       auto back_index = back(rcs);
//       // task: find child the child node for whom this index corresponds
//       if constexpr (containerBlocked()) {
//         // easy case, the back_index is exactly the index of the child node
//         return childContainerSize(back_index, pop_back(rcs));
//       } else {
//         // here we need to "recover" the child index that describes the
//         // back_index (inverse of firstContainerIndex operation)
//         assert(_gt_used[gt_index]);
//         auto dof_begin =
//           begin(fixedSize() ? *_gt_dof_offsets : *_entity_dof_offsets);
//         if (fixedSize())
//           dof_begin += gt_index * node().degree();
//         else
//           dof_begin +=
//             ((*_gt_entity_offsets)[gt_index] + entity_index) * node().degree();
//         auto dof_end = dof_begin + node().degree();
//         auto dof_it = std::upper_bound(dof_begin, dof_end, back_index);
//         auto next = accumulate_back(rcs, SizeType{ 0 });
//         if (dof_it != dof_begin) {
//           std::advance(dof_it, -1);
//           assert(back(cs) >= *dof_it);
//           next = accumulate_back(next, -(*dof_it));
//         }
//         std::size_t child_index = std::distance(dof_begin, dof_it);
//         assert(node().degree() > child_index);
//         return childContainerSize(child_index, next);
//       };
//     }
//   }

//   // this method needs be called only on the root node of the local space
//   // tree the fixed and variable size updates propagate their calls down the
//   // tree. In particular, this produces a depth first algorithm. Before every
//   // node: Allocate and set-up node. Before/After children: Carry partial
//   // calculation of the children sizes After every node: Calculate final sizes
//   // of children and accumulate to obtain offets.
//   void update()
//   {
//     // if constexpr (Dune::Concept::MutableEntitySet<EntitySet,0>) {
//     //   entitySet().addCodim(0); // we always need cells
//     //   const std::size_t dim = EntitySet::dimension;
//     //   auto codim_range = std::make_index_sequence<dim + 1>{};

//     //   Dune::Hybrid::forEach(codim_range, [&](auto codim) {
//     //     if (mayContainCodim(codim))
//     //       entitySet().addCodim(codim);
//     //   });

//     //   entitySet().update();
//     // }

//     updateFixedSizeOrderings();
//     if (not prioryFixedSize())
//       updateVariableSizeOrderings();
//   }

// protected:
//   // A priory compile-time information if a given codimension may contain DOFs wrt a grid entity
//   // If false, there is a guarantee that this map will never contain such a
//   // codimension. If true, codimension may or may not be used at run-time
//   template<class EntityCodim>
//   [[nodiscard]] static constexpr auto mayContainCodim(EntityCodim entity_codim)
//   {
//     if constexpr (Concept::LeafTreeNode<Node>) {
//       constexpr std::size_t entity_dim = EntitySet::dimension - entity_codim;
//       // dimension of the finite element domain (perhaps embedded on sub entities)
//       using FEM = typename Node::Space::Traits::FiniteElementMap;
//       constexpr std::size_t fem_dim = FEM::Traits::FiniteElement::Traits::LocalBasisType::Traits::dimDomain;
//       if constexpr (entity_dim > fem_dim) {
//         // requested dim is higher than the finite element dimension thus not contained
//         return std::false_type{};
//       } else if constexpr (requires { FEM::hasDOFs(int{}); }) {
//         // in this case we can check if a DOF is included or not
//         constexpr std::size_t fem_codim = fem_dim - entity_dim;
//         constexpr bool has_dofs = FEM::hasDOFs(static_cast<int>(fem_codim));
//         return std::integral_constant<bool, has_dofs>{};
//       } else {
//         return std::true_type{};
//       }
//     } else if constexpr (Concept::ArrayTreeNode<Node> ||
//                          Concept::VectorTreeNode<Node>) {
//       return Node::ChildType::mayContainCodim(entity_codim);
//     } else if constexpr (Node::isComposite) {
//       auto unfold_children = [&](auto... i) {
//         constexpr bool has_dofs =
//           (TypeTree::template Child<Node, i>::mayContainCodim(entity_codim) || ...);
//         return std::integral_constant<bool, has_dofs>{};
//       };
//       auto indices = std::make_index_sequence<Node::degree()>{};
//       return unpackIntegerSequence(unfold_children, indices);
//     } else {
//       static_assert(Dune::AlwaysFalse<Node>{}, "Not known Node Type");
//     }
//   }

// private:
//   //! Compile-time information of maximum codimensions used by this map
//   //! @note Notice that less codimenions may be actually used at run-time
//   [[nodiscard]] static auto constexpr maxCodimCount()
//   {
//     auto sequence = std::make_index_sequence<1 + EntitySet::dimension>{};

//     constexpr std::size_t count = Dune::unpackIntegerSequence(
//       [&](auto... codim) {
//         constexpr std::size_t one{ 1 }, zero{ 0 };
//         return ((EntityOrderingNode::mayContainCodim(codim) ? one : zero) +
//                 ...);
//       },
//       sequence);
//     return std::integral_constant<std::size_t, count>{};
//   }

//   //! Setup ordering for fixed size maps
//   //! @note Recursive function, only call this from root node.
//   void updateFixedSizeOrderings()
//   {

//     const std::size_t dim = EntitySet::dimension;

//     _fixed_size = prioryFixedSize();
//     _max_local_coeff_count = 0;
//     _block_count = 0;

//     if constexpr (prioryFixedSize()) {
//       // reset falgs and offsets
//       _codim_used.reset();
//       const auto gt_count = GlobalGeometryTypeIndex::size(dim);
//       _gt_used.assign(gt_count, false);
//       if (not _gt_dof_offsets)
//         _gt_dof_offsets = std::make_unique<std::vector<SizeType>>();
//       _gt_dof_offsets->assign(
//         gt_count * std::max<std::size_t>(1, node().degree()), 0);
//     }

//     // fill out flags and offsets depending on the node type
//     if constexpr (Concept::LeafTreeNode<Node>) {

//       using FEM = typename Node::Space::Traits::FiniteElementMap;
//       constexpr std::size_t fem_dim = FEM::Traits::FiniteElement::Traits::LocalBasisType::Traits::dimDomain;
//       constexpr std::size_t fem_codim = EntitySet::dimension - fem_dim;

//       if constexpr (prioryFixedSize()) {
//         for (std::size_t codim = fem_codim; codim <= EntitySet::dimension; ++codim) {
//           for (const auto& gt : entitySet().indexSet().types(codim)) {
//             SizeType size = node().space().finiteElementMap().size(gt);
//             const auto gt_index = GlobalGeometryTypeIndex::index(gt);
//             (*_gt_dof_offsets)[gt_index] = size;
//             _gt_used[gt_index] = size > 0;
//             _block_count += size * entitySet().size(gt);
//             assert(codim == dim - gt.dim());
//             _codim_used[codim] = _codim_used[codim] or (size > 0);
//           }
//         }
//         // collect max entity sides on fem dimension for an entity of codimension 0
//         int max_sub_entities = 0;
//         for (const auto& gt : entitySet().indexSet().types(0)) {
//           using Dune::referenceElement;
//           auto ref_el = referenceElement<double, EntitySet::dimension>(gt);
//           max_sub_entities = std::max(max_sub_entities, ref_el.size(EntitySet::dimension - fem_dim));
//         }
//         node().setMaxSubEntities(max_sub_entities);
//         _max_local_coeff_count = max_sub_entities * node().space().finiteElementMap().maxLocalSize();
//       }
//     } else {
//       forEach(node(), [&](auto& child, auto i) {
//         // first, set up child gt collection
//         child.updateFixedSizeOrderings();
//         // then, accumulate child results to this node
//         if constexpr (prioryFixedSize()) {
//           // this node can only be fixed size if child is also fixed size
//           assert(child.prioryFixedSize());

//           // properties contained in child nodes are also contained here
//           for (std::size_t codim = 0; codim <= dim; ++codim)
//             _codim_used[codim] =
//               _codim_used[codim] or child.containsCodim(codim);

//           for (std::size_t gt = 0; gt < _gt_used.size(); ++gt)
//             _gt_used[gt] = _gt_used[gt] or child.containsGeometry(gt);

//           _max_local_coeff_count += child.maxLocalCount();

//           if (not containerBlocked())
//             _block_count += child.blockCount();

//           // get size of child nodes
//           for (std::size_t gt = 0; gt < _gt_used.size(); ++gt)
//             (*_gt_dof_offsets)[gt * node().degree() + i] =
//               child.blockCount(gt);
//         }
//       });
//     }

//     if constexpr (prioryFixedSize()) {
//       // finally, convert child gt sizes into offsets
//       auto it = begin(*_gt_dof_offsets);
//       const auto advance = std::max<std::size_t>(1, node().degree());
//       while (it != end(*_gt_dof_offsets))
//         it = std::partial_sum(it, it + advance, it);
//     }
//   }

//   //! Pre-allocate objects on this node related to the variable size ordering
//   void allocateVariableSizeOrdering()
//   {
//     static_assert(not prioryFixedSize());
//     _codim_used.reset();
//     const auto gt_count = GlobalGeometryTypeIndex::size(EntitySet::dimension);
//     _gt_used.assign(gt_count, false);

//     if (not _gt_dof_offsets)
//       _gt_dof_offsets = std::make_unique<std::vector<SizeType>>();
//     _gt_dof_offsets->assign(
//       gt_count * std::max<std::size_t>(1, node().degree()), GT_UNUSED);

//     if (not _gt_entity_offsets)
//       _gt_entity_offsets = std::make_unique<std::vector<SizeType>>();
//     _gt_entity_offsets->assign(gt_count + 1, 0);
//   }

//   //! Collect used geometry types on leaf nodes (variable size)
//   template<class Entity>
//   void collectLeafGeometryTypes(const Entity& entity)
//   {
//     static_assert(not prioryFixedSize());
//     static_assert(Concept::LeafTreeNode<Node>);
//     static_assert(Dune::Concept::EntityExtended<Entity>);
//     assert(not fixedSize());

//     using FEM = typename Node::Space::Traits::FiniteElementMap;
//     constexpr std::size_t fem_dim = FEM::Traits::FiniteElement::Traits::LocalBasisType::Traits::dimDomain;
//     constexpr std::size_t fem_codim = EntitySet::dimension - fem_dim;

//     const FEM& fem = node().space().finiteElementMap();
//     std::size_t max_coeff_count = 0;
//     for (const auto& sub_entity : subEntities(entity, Dune::Codim<fem_codim>{})) {
//       const auto& finite_element = fem.find(sub_entity);
//       using FEM = typename Node::Space::Traits::FiniteElementMap;
//       using FESwitch = FiniteElementInterfaceSwitch<typename FEM::Traits::FiniteElement>;
//       const auto& coeffs = FESwitch::coefficients(finite_element);
//       max_coeff_count += coeffs.size();

//       const auto& ref_el = referenceElement(sub_entity.geometry());
//       for (std::size_t i = 0; i < coeffs.size(); ++i) {
//         const auto& key = coeffs.localKey(i);
//         auto gt_index = GlobalGeometryTypeIndex::index(ref_el.type(key.subEntity(), key.codim()));
//         _gt_used[gt_index] = true;
//         _codim_used.set(fem_codim + key.codim());
//       }
//     }
//     _max_local_coeff_count = std::max<std::size_t>(_max_local_coeff_count, max_coeff_count);
//     node().setMaxSubEntities(std::max<int>(node().maxSubEntities(), entity.subEntities(fem_codim)));
//   }

//   //! Collect geometry types for all nodes (variable size)
//   //! @note Use after every leaf node called `collectLeafGeometryTypes`
//   //! @note Recursive function, only call this from root node.
//   void collectGeometryTypes()
//   {
//     _fixed_size_possible = true;

//     if constexpr (not Concept::LeafTreeNode<Node>) {
//       forEach(node(), [&](auto& child, auto path) {
//         child.collectGeometryTypes();

//         if constexpr (not prioryFixedSize()) {
//           // properties contained in child nodes are also contained here
//           for (std::size_t codim = 0; codim <= EntitySet::dimension; ++codim)
//             _codim_used[codim] =
//               _codim_used[codim] or child.containsCodim(codim);

//           for (std::size_t gt = 0; gt < _gt_used.size(); ++gt)
//             _gt_used[gt] = _gt_used[gt] or child.containsGeometry(gt);
//         }
//       });
//     }

//     // create offset of indices for contained geometry types
//     if constexpr (not prioryFixedSize()) {
//       for (std::size_t codim = 0; codim <= EntitySet::dimension; ++codim) {
//         for (const auto& gt : entitySet().indexSet().types(codim)) {
//           const auto gt_index = GlobalGeometryTypeIndex::index(gt);
//           if (containsGeometry(gt_index))
//             (*_gt_entity_offsets)[gt_index + 1] = entitySet().indexSet().size(gt);
//         }
//         std::partial_sum(begin(*_gt_entity_offsets),
//                         end(*_gt_entity_offsets),
//                         begin(*_gt_entity_offsets));
//         if (not _entity_dof_offsets)
//           _entity_dof_offsets = std::make_unique<std::vector<SizeType>>();
//         _entity_dof_offsets->assign(_gt_entity_offsets->back() *
//                                       std::max<std::size_t>(node().degree(), 1),
//                                     0);
//       }
//     }
//   }

//   //! Gather sizes for entity sizes on the leaf node from local keys (variable
//   //! size)
//   //! @note Use this after geometry types have been collected
//   //! @note This class additionally checks if sizes change between different
//   //! entities, thus, allowing us to know if we can compress variable size data
//   //! into fixed size data
//   template<class Entity>
//   void collectEntitySizes(const Entity& entity, std::vector<SizeType>& gt_cache)
//   {
//     static_assert(not prioryFixedSize());
//     static_assert(Concept::LeafTreeNode<Node>);
//     if (_fixed_size_possible)
//       std::fill(gt_cache.begin(), gt_cache.end(), GT_UNUSED);

//     using FEM = typename Node::Space::Traits::FiniteElementMap;
//     constexpr std::size_t fem_dim = FEM::Traits::FiniteElement::Traits::LocalBasisType::Traits::dimDomain;
//     constexpr std::size_t fem_codim = EntitySet::dimension - fem_dim;

//     const FEM& fem = node().space().finiteElementMap();
//     for (std::size_t s = 0; s != entity.subEntities(fem_codim); ++s) {
//       const auto& sub_entity = [&]{
//         if constexpr (fem_codim == 0)
//           return entity;
//         else
//           return entity.template subEntity<fem_codim>(s);
//       }();

//       const auto& finite_element = fem.find(sub_entity);
//       if (finite_element.type() != entity.type())
//         DUNE_THROW(RangeError, "Dune::GeometryType of the local finite element and entity do not match!");
//       using FEM = typename Node::Space::Traits::FiniteElementMap;
//       using FESwitch =
//         FiniteElementInterfaceSwitch<typename FEM::Traits::FiniteElement>;
//       const auto& coeffs = FESwitch::coefficients(finite_element);

//       const auto& ref_el = referenceElement(sub_entity.geometry());
//       for (std::size_t dof = 0; dof != coeffs.size(); ++dof) {
//         const LocalKey& key = coeffs.localKey(dof);
//         const SizeType gt_index = GlobalGeometryTypeIndex::index(ref_el.type(key.subEntity(), key.codim()));
//         const SizeType entity_index = entitySet().indexSet().subIndex(sub_entity, key.subEntity(), fem_codim + key.codim());
//         const SizeType index = (*_gt_entity_offsets)[gt_index] + entity_index;
//         gt_cache[gt_index] = (*_entity_dof_offsets)[index] =
//           std::max<SizeType>((*_entity_dof_offsets)[index], key.index() + 1);
//       }
//     }

//     // as long as we haven't discarded possible fixed size, we try to find
//     // out if the seen geometry types have fixed size
//     if (_fixed_size_possible) {
//       for (std::size_t i = 0; i < gt_cache.size(); ++i) {
//         // update unused entries
//         if ((*_gt_dof_offsets)[i] == GT_UNUSED)
//           (*_gt_dof_offsets)[i] = gt_cache[i];
//         // if cache does not match global gt sizes, we need to discard fixed
//         // size computations
//         if ((*_gt_dof_offsets)[i] != gt_cache[i]) {
//           _fixed_size_possible = false;
//           break;
//         }
//       }
//     }
//   }

//   //! Convert size vectors into offset vectors
//   //! This class first identifies if fixed size is possible, then accumulate
//   //! offsets in the corresponding data structure
//   //! @note Recursive function, only call this from root node.
//   void accumulateEntityOffsets()
//   {
//     _block_count = 0;
//     if constexpr (Concept::LeafTreeNode<Node>) {
//       // if we did't discard fixed size by this point, we can use the
//       // fixed size geometry type sizes
//       if (_fixed_size_possible) {
//         _entity_dof_offsets.reset(); // discard individual entity sizes
//         _fixed_size = true;
//       }
//       // mask out GT_UNUSED for geometry types that really weren't used
//       for (std::size_t codim = 0; codim <= EntitySet::dimension; ++codim) {
//         for (const auto& gt : entitySet().indexSet().types(codim)) {
//           auto& size = (*_gt_dof_offsets)[GlobalGeometryTypeIndex::index(gt)];
//           if (size == GT_UNUSED)
//             size = 0;
//           if (_fixed_size)
//             _block_count += size * entitySet().size(gt);
//         }
//       }
//       if (not _fixed_size)
//         _block_count = std::accumulate(
//           begin(*_entity_dof_offsets), end(*_entity_dof_offsets), 0);
//     } else {
//       // update node properties
//       _fixed_size_possible = true;
//       forEach(node(), [&](auto& child, auto path) {
//         // update sub-tree
//         child.accumulateEntityOffsets();
//         _fixed_size_possible &= child.fixedSize();
//         _max_local_coeff_count += child.maxLocalCount();
//       });

//       const std::size_t dim = EntitySet::dimension;
//       const std::size_t gt_count = GlobalGeometryTypeIndex::size(dim);
//       if (_fixed_size_possible) {
//         // we need to update gt sizes from children and convert them to offsets
//         forEach(node(), [&](auto& child, auto i) {
//           for (std::size_t codim = 0; codim <= EntitySet::dimension; ++codim) {
//             for (const auto& gt : entitySet().indexSet().types(codim)) {
//               const auto gt_index = GlobalGeometryTypeIndex::index(gt);
//               const auto gt_offset = gt_index * node().degree() + i;
//               const auto cb_count = child.blockCount(gt_index);
//               (*_gt_dof_offsets)[gt_offset] = cb_count;
//               _block_count += cb_count * entitySet().size(gt);
//               if (i != 0)
//                 (*_gt_dof_offsets)[gt_offset] =
//                   (*_gt_dof_offsets)[gt_offset - 1] + cb_count;
//             }
//           }
//         });

//         _fixed_size = true;
//       } else {
//         // no fixed size was possible, save offsets for each entity:
//         //   for every entity we already have block count,
//         //   then, we just need to carry such count to the next entity value
//         SizeType index = 0;
//         for (SizeType gt = 0; gt < gt_count; ++gt) {
//           if (not containsGeometry(gt))
//             continue;
//           assert((*_gt_entity_offsets)[gt] <= (*_gt_entity_offsets)[gt + 1]);
//           const SizeType entity_count =
//             (*_gt_entity_offsets)[gt + 1] - (*_gt_entity_offsets)[gt];
//           for (SizeType e_index = 0; e_index < entity_count; ++e_index) {
//             SizeType carry = 0;
//             forEach(node(), [&](auto& child, auto path) {
//               carry += child.blockCount(gt, e_index);
//               (*_entity_dof_offsets)[index++] = carry;
//             });
//             _block_count += containerBlocked() ? (carry != 0) : carry;
//           }
//         }
//       }
//     }
//   }

//   //! Setup ordering for variable size maps
//   //! @note Recursive function, only call this from root node.
//   void updateVariableSizeOrderings()
//   {

//     forEachNode(node(), []<class T>(T& node, auto path) {
//       if constexpr (not T::prioryFixedSize())
//         node.allocateVariableSizeOrdering();
//     });

//     for (const auto& entity : elements(entitySet())) {
//       forEachLeafNode(node(), [&]<class T>(T& leaf, auto path) {
//         if constexpr (not T::prioryFixedSize())
//           leaf.collectLeafGeometryTypes(entity);
//       });
//     }

//     collectGeometryTypes();

//     { // construct cache outside entity collection to avoid reallocation
//       const std::size_t dim = EntitySet::dimension;
//       std::vector<SizeType> gt_cache(GlobalGeometryTypeIndex::size(dim), 0);

//       for (const auto& entity : elements(entitySet())) {
//         forEachLeafNode(node(), [&]<class T>(T& leaf, auto path) {
//           if constexpr (not T::prioryFixedSize())
//             leaf.collectEntitySizes(entity, gt_cache);
//         });
//       }
//     }
//     accumulateEntityOffsets();
//   }

// private:
//   //! Cast to node implementation (Barton–Nackman trick)
//   const Node& node() const noexcept { return static_cast<const Node&>(*this); }
//   Node& node() noexcept { return static_cast<Node&>(*this); }

//   CodimFlag _codim_used;
//   std::vector<bool> _gt_used;
//   MergingStrategy _merging_strategy;
//   std::size_t _max_local_coeff_count, _block_count;
//   bool _fixed_size;
//   bool _fixed_size_possible;


// protected:
//   /**
//    *  Data for this node may be stored in fixed or variable size form:
//    *
//    * * Fixed Size:
//    *    In this case, all entities of a given geometry type look the same.
//    *    Thus, we just need to store the offset between nodes for each geometry
//    *    type.
//    *
//    *    gt_index        ||    cell   || ... ||   vertex  || ... ||
//    *    child_index     || 0 | 1 | 2 || ... || 0 | 1 | 2 || ... ||
//    *    _gt_dof_offsets || 2 | 3 | 8 || ... || 1 | 2 | 3 || ... ||
//    *
//    * * Variable Size:
//    *    In this case, every entity has potentially different sizes so we have
//    *    to store each offset individully. This information is stored in the
//    *    `_entity_dof_offsets`. Since grids have a different indexation for
//    *    each geometry type, we store an offset for these geometry types in
//    *    `_gt_entity_offsets`. This works similarly as the
//    *    MultipleCodimMultipleGeomTypeMapper object in dune-grid works. This
//    *    allows us to keep everything as packed and cache friendly as possible.
//    *
//    *    gt_index              || cell                          || vertex    ||
//    *    _gt_entity_offsets    || *                             || *         ||
//    *                             |                                |
//    *                             v                                v
//    *    entity_index          ||   cell0   ||   cell1   || ... ||  vertex0  ||
//    *    child_index           || 0 | 1 | 2 || 0 | 1 | 2 || ... || 0 | 1 | 2 ||
//    *    _entity_dof_offsets   || 2 | 3 | 8 || 0 | 0 | 0 || ... || 1 | 2 | 3 ||
//    *
//    * @todo Try to use MultipleCodimMultipleGeomTypeMapper for variable size.
//    * If the abstraction does not fit here, document why.
//    */
//   std::shared_ptr<std::vector<SizeType>> _gt_dof_offsets;
//   std::shared_ptr<std::vector<SizeType>> _gt_entity_offsets;
//   std::shared_ptr<std::vector<SizeType>> _entity_dof_offsets;
// };

// /**
//  * @brief Leaf implementation of an EntityOrderingNode
//  * @note This is the first ordering constructed on every ordering tree
//  *
//  * @tparam LeafDFS   Type containing a finite element map and a
//  *                        merging strategy
//  */
// template<Concept::Impl::SpaceLeaf LeafDFS>
// class LeafEntityOrdering
//   : public TypeTree::LeafNode
//   , public EntityOrderingNode<LeafEntityOrdering<LeafDFS>,
//                               typename LeafDFS::Traits::MergingStrategy>
// {
//   using TreeNode = TypeTree::LeafNode;
//   using OrderingNode =
//     EntityOrderingNode<LeafEntityOrdering<LeafDFS>,
//                        typename LeafDFS::Traits::MergingStrategy>;
//   using FE = typename LeafDFS::Traits::FiniteElementMap::Traits::FiniteElement;
//   using ES = typename LeafDFS::Traits::MergingStrategy::EntitySet;
//   static constexpr std::size_t fem_dim = FE::Traits::LocalBasisType::Traits::dimDomain;
//   static constexpr std::size_t fem_codim = ES::dimension - fem_dim;
// public:
//   using Space = LeafDFS;
//   using SizeType = typename LeafDFS::Traits::MergingStrategy::SizeType;

//   //! Construct an ordering based on the templated discrete-function-space
//   LeafEntityOrdering(const Space& space)
//     : TreeNode{}
//     , OrderingNode{ space.mergingStrategy() }
//     , _space{ space }
//   {
//   }

//   //! Access to the underlying discrete-function-space
//   const Space& space() const { return _space; }

//   //! Access to the underlying discrete-function-space
//   Space& space() { return _space; }

//   [[nodiscard]] int maxSubEntities() const { return _max_sub_entities; }
//   void setMaxSubEntities(int s) { _max_sub_entities = s; }

//   /**
//    * @brief Coefficient vector factory
//    *
//    * @tparam BackendTraits    A traits class providing container types
//    * @return constexpr auto   a suitable container type for the underlying
//    * ordering
//    */
//   template<class BackendTraits>
//   static constexpr auto makeVectorContainer()
//   {
//     // common size for all geometry types
//     constexpr auto gt_common_size = commonSizePerGeometryType();

//     auto field = BackendTraits::template makeField<Space>();
//     using Field = std::decay_t<decltype(field)>;
//     if constexpr (gt_common_size)
//       return BackendTraits::template makeArray<Field, gt_common_size.value()>();
//     else
//       return BackendTraits::template makeVector<Field>();
//   }

//   //! gets a common size for all active geometry types if available at compile time
//   // this needs the the Space::Traits::FiniteElementMap::size(...) is static constexpr.
//   static consteval std::optional<std::size_t> commonSizePerGeometryType() {
//     using FEM = typename Space::Traits::FiniteElementMap;
//     std::size_t size = 0;
//     const auto fem_size = [](auto gt) consteval {
//       if constexpr (requires { { FEM::size(gt) } -> std::convertible_to<std::size_t>; })
//         return FEM::size(gt);
//       else
//         return 0;
//     };
//     // iterate over all possible geometry types and find out if all share the same size
//     for (std::size_t dim = 0; dim <= FEM::dimension ; ++dim) {
//       std::size_t gt_size = fem_size(GeometryTypes::none(dim));
//       if (gt_size > 0) {
//         if (size > 0 and size != gt_size)
//           return std::nullopt;
//         else
//           size = gt_size;
//       }
//       for (std::size_t topology_id = 0 ; topology_id < (std::size_t{1} << dim) ; ++topology_id) {
//         std::size_t gt_size = fem_size(GeometryType(topology_id,dim));
//         if (gt_size > 0) {
//           if (size > 0 and size != gt_size)
//             return std::nullopt;
//           else
//             size = gt_size;
//         }
//       }
//     }
//     if (size == 0)
//       return std::nullopt;
//     else
//       return size;
//   }

// private:

//   template<Concept::MultiIndex ViewPath, Concept::MultiIndex ContainerIndex>
//   class LocalIndexSet : public TypeTree::LeafNode
//   {
//     using DisjointCodimClosure = decltype(std::declval<LeafEntityOrdering>().disjointCodimClosure());
//   public:
//     using size_type = SizeType;
//     using MultiIndex = ContainerIndex;
//     using Path = ViewPath;

//     //! Class constructing the local space
//     LocalIndexSet(const Path& view_path, const DisjointCodimClosure& disjoint_codim_closure)
//       : TypeTree::LeafNode{}
//       , _indices{}
//       , _tree_offset{ 0 }
//       , _view_path{view_path}
//       , _disjoint_codim_closure{disjoint_codim_closure}
//     {
//     }

//     LocalIndexSet(const LocalIndexSet&) = delete;
//     LocalIndexSet(LocalIndexSet&&) = default;

//     //! Grant mutable access to the underlying local container indices
//     std::vector<MultiIndex>& indices() noexcept { return _indices; }

//     //! Obtain a container index (Inner2Outer) to the i-th local degree of freedom
//     [[nodiscard]] MultiIndex index(size_type dof) const noexcept
//     {
//       assert(dof < size());
//       if (optimizeFastDG() and disjointCodimClosure()) {
//         // In this case, we know that indices are contiguous and can be
//         //   reconstructed from the local index so there is no need to fill
//         //   the whole vector.
//         return accumulate_back(_indices[0], dof);
//       } else {
//         return _indices[dof];
//       }
//     }


//     void unbind() noexcept {
//       _indices.clear();
// #ifndef NDEBUG
//       _tree_offset = std::numeric_limits<std::size_t>::max()/2;
// #endif
//     }

//     // returns a local view path: join(orderingViewPath(), subEntityPath())
//     [[nodiscard]] Path path() const noexcept {
//       return _view_path;
//     }

//     [[nodiscard]] auto orderingViewPath() const noexcept {
//       if constexpr (fem_dim != ES::dimension)
//         return pop_back(_view_path);
//       else
//         return _view_path;
//     }

//     [[nodiscard]] auto subEntityPath() const noexcept {
//       if constexpr (fem_dim != ES::dimension)
//         return back(_view_path);
//       else
//         return multiIndex();
//     }

//     //! Sets an offest for the local degrees of freedom
//     void setTreeOffset(size_type tree_offset) noexcept { _tree_offset = tree_offset; }

//     //! Returns unique index whitin the tree dofs
//     [[nodiscard]] size_type localIndex(size_type dof) const noexcept
//     {
//       return _tree_offset + dof;
//     }

//     //! Amount of degrees of freedom for this node
//     [[nodiscard]] size_type size() const noexcept { return _indices.size(); }

//     //! Bool whether dofs are shared to other entity local spaces
//     [[nodiscard]] auto disjointCodimClosure() const noexcept
//     {
//       return _disjoint_codim_closure;
//     }

//     [[nodiscard]] static constexpr bool optimizeFastDG() noexcept
//     {
//       return DUNE_ASSEMBLER_FAST_DG_OPTIMIZATION;
//     }

//     [[nodiscard]] friend constexpr decltype(auto) localContainerEntry(auto& container, const LocalIndexSet& node, size_type dof) noexcept {
//       return containerEntry(container, node.index(dof));
//     }

//     template<class OtherLocalIndexSet>
//     [[nodiscard]] friend decltype(auto) localContainerEntry(auto&& container,
//                                          const LocalIndexSet& test_lis,
//                                          size_type test_dof,
//                                          const OtherLocalIndexSet& trial_lis,
//                                          size_type trial_dof) noexcept
//     {
//       static_assert(MultiIndex::size() == OtherLocalIndexSet::MultiIndex::size());
//       MultiIndex i = test_lis.index(test_dof);
//       // TODO check that `trial_lis` has the same multi-index direction semantics
//       Concept::MultiIndex auto j = trial_lis.index(trial_dof);
//       Concept::MultiIndex auto k = containerIndexMerge(container, j, i);
//       return containerEntry(container, k);
//     }


//   private:

//     std::vector<MultiIndex> _indices;
//     size_type _tree_offset;
//     // the following objects may be compile-time or run-time values, in the
//     // first case (i.e. MultiIndex<> and std::bool_constant<...>), they may be
//     // completely empty thus we do not rely on their addresses and try make data
//     // layout of this class smaller.
//     [[no_unique_address]] const Path _view_path;
//     [[no_unique_address]] const DisjointCodimClosure _disjoint_codim_closure;
//   };

//   template<Concept::MultiIndex ViewPath, Concept::MultiIndex ContainerIndex>
//   class SubEntityLocalIndexSet : public TypeTree::DynamicPowerNode<LocalIndexSet<ViewPath,ContainerIndex>>
//   {
//     using Base = TypeTree::DynamicPowerNode<LocalIndexSet<ViewPath,ContainerIndex>>;
//   public:
//     using size_type = SizeType;
//     using MultiIndex = ContainerIndex;
//     SubEntityLocalIndexSet(typename Base::NodeStorage&& storage)
//       : Base{ std::move(storage) }
//     {
//     }
//   };


//   /**
//    * @brief A realization of a local space node
//    * This class provides an ordering to the space induced by the
//    * discrete-function-space but restricted to a particular entity. Countrary to
//    * LeafEntityOrdering, this class is only instantiated after the whole
//    * ordering tree has been constructed.
//    *
//    * @note This class fullfils the Concept::LocalViewLeaf, thus, is the
//    * facade class for the user.
//    * @note ContainerIndex usually differs between different nodes of the same
//    * ordering. In particular, it is an hybrid multi-index where known parent
//    * indices for this node may be pre-filled at compile-time.
//    *
//    * @tparam ContainerIndex  The type to store container indices
//    */
//   template<Concept::MultiIndex ViewPath, Concept::MultiIndex ContainerIndex>
//   class LocalView : public LocalIndexSet<ViewPath, ContainerIndex>
//   {
//     using DisjointCodimClosure = decltype(std::declval<LeafEntityOrdering>().disjointCodimClosure());
//   public:
//     using FiniteElement = FE;
//     using EntitySet = ES;
//     using Element = typename EntitySet::template Codim<fem_codim>::Entity;
//     using size_type = SizeType;
//     using MultiIndex = ContainerIndex;
//     using Path = ViewPath;
//     static constexpr std::size_t dimDomain = fem_dim;

//     //! Local space traits (compatiblility layer for PDELab)
//     struct Traits
//     {
//       using FiniteElementType /*[[deprecated]]*/ = typename Space::Traits::
//         FiniteElementMap::Traits::FiniteElement;
//       using FiniteElement /*[[deprecated]]*/ = typename Space::Traits::
//         FiniteElementMap::Traits::FiniteElement;
//       using SizeType /*[[deprecated]]*/ = typename LeafDFS::Traits::MergingStrategy::SizeType;
//     };

//     //! Class constructing the local space
//     LocalView(const Path& view_path, const DisjointCodimClosure& disjoint_codim_closure)
//       : LocalIndexSet<ViewPath, ContainerIndex>{ view_path, disjoint_codim_closure }
//       , _entity_view{ nullptr }
//       , _fe_view{ nullptr }
//     {
//     }

//     LocalView(const LocalView&) = delete;
//     LocalView(LocalView&&) = default;

//     LocalView& operator=(const LocalView&) = delete;
//     LocalView& operator=(LocalView&&) = default;


//     //! Binds a finite element: rvalues are stored, lvalues are referenced
//     template<class FE>
//     void bindFiniteElement(FE&& finite_element) noexcept
//     {
//       static_assert(std::same_as<std::decay_t<FE>, FiniteElement>);
//       if constexpr (std::is_rvalue_reference_v<FE&&>) {
//         static_assert(std::move_constructible<FiniteElement>);
//         static_assert(std::is_move_assignable_v<FiniteElement>);
//         // we will pay the price for unique_ptr ctor on our first bind
//         if (_fe_store) [[likely]]
//           (*_fe_store) = std::move(finite_element);
//         else
//           _fe_store =
//             std::make_unique<FiniteElement>(std::move(finite_element));
//         _fe_view = _fe_store.get();
//       } else {
//         _fe_view = &finite_element;
//       }
//     }

//     //! Binds a view on the entity. Internally, we keep a reference the object
//     void bindElement(const Element* entity) noexcept {
//       _entity_view = entity;
//     }

//     void unbind() noexcept {
//       LocalIndexSet<ViewPath, ContainerIndex>::unbind();
//       _fe_view = nullptr;
//       _entity_view = nullptr;
//     }

//     //! Returns a view on the local finite element
//     [[nodiscard]] const FiniteElement& finiteElement() const noexcept
//     {
//       assert(_fe_view);
//       return *_fe_view;
//     }

//     //! Returns a view on the bound entity
//     [[nodiscard]] const Element& element() const noexcept
//     {
//       assert(boundElement() && "Entity is not bound: local function is not bound or it has no support on the bound entity");
//       return *_entity_view;
//     }

//     [[nodiscard]] bool boundElement() const noexcept {
//       return _entity_view != nullptr;
//     }

//   private:
//     std::unique_ptr<FiniteElement> _fe_store;
//     Element const* _entity_view;
//     FiniteElement const* _fe_view;
//   };

//   template<Concept::MultiIndex ViewPath, Concept::MultiIndex ContainerIndex>
//   class SubEntityLocalView : public TypeTree::DynamicPowerNode<LocalView<ViewPath, ContainerIndex>> {
//     using LV = LocalView<ViewPath, ContainerIndex>;
//     using Base = TypeTree::DynamicPowerNode<LocalView<ViewPath, ContainerIndex>>;
//   public:

//     using size_type = SizeType;
//     using MultiIndex = ContainerIndex;

//     SubEntityLocalView(
//       const typename Base::NodeStorage&& storage)
//       : Base{ std::move(storage) }
//     {
//     }

//     void bindElement(const auto& entity) noexcept {
//       constexpr std::size_t fem_dim = LV::FiniteElement::Traits::LocalBasisType::Traits::dimDomain;
//       constexpr std::size_t fem_codim = LV::EntitySet::dimension - fem_dim;
//       _sub_entities.resize(entity->subEntities(fem_codim));
//       // use emplace in order to use the move constructor (move assignement did not work on multidomainggrid+UGGrid)
//       for (std::size_t s = 0; s != _sub_entities.size(); ++s) {
//         _sub_entities[s].emplace(entity->template subEntity<fem_codim>(s));
//         this->child(s).bindElement(&_sub_entities[s].value());
//       }
//       assert(_sub_entities.size() <= Base::degree());
//     }

//   private:
//     std::vector<std::optional<typename LV::Element>> _sub_entities;
//   };

// public:
//   /**
//    * @brief Creates a local ordering pointer based on a root global ordering
//    *
//    * @tparam Ordering   The root entity set ordering (it contains this object as
//    * a node)
//    * @tparam Prefix     A prefix container tree to reach this node from the root
//    * ordering
//    * @param ordering    The root entity set ordering (it contains this object as
//    * a node)
//    * @param prefix      A prefix container tree to reach this node from the root
//    * ordering
//    * @return auto       A shared pointer for a local ordering
//    */
//   template<class Ordering, Concept::MultiIndex Prefix, Concept::MultiIndex SubSpacePath>
//   auto makeLocalIndexSet(const std::shared_ptr<Ordering>& ordering,
//                          const Prefix& prefix, const SubSpacePath& sub_space_path) const
//   {
//     static_assert(SubSpacePath::size() <= Prefix::size(), "Sub space path cannot be larger than the total path from root");

//     constexpr std::size_t sub_space_depth = SubSpacePath::size();
//     constexpr std::size_t view_depth = Prefix::size() - sub_space_depth;
//     auto view_path = unpackIntegerSequence([&](auto... i){
//       return multiIndex(prefix[index_constant<sub_space_depth+i>{}] ...);
//     }, std::make_index_sequence<view_depth>{});

//     assert(&child(*ordering, prefix) == this &&
//            "This class should be a node of the root ordering");
//     // From the ordering, we extract the type of the container index for this node
//     using ContainerIndex =
//       decltype(ordering->firstContainerIndex(prefix, SizeType{}, SizeType{}));
//     // and use it to instantiate the local ordering
//     using FEM = typename Space::Traits::FiniteElementMap;
//     using EntitySet = typename Space::Traits::MergingStrategy::EntitySet;
//     constexpr std::size_t fem_dim = FEM::Traits::FiniteElement::Traits::LocalBasisType::Traits::dimDomain;
//     if constexpr (fem_dim == EntitySet::dimension) {
//       return std::make_unique<LocalIndexSet<decltype(view_path), ContainerIndex>>(view_path, this->disjointCodimClosure());
//     } else {
//       using LIS = LocalIndexSet<decltype(push_back(view_path,0)), ContainerIndex>;
//       using SLIS = SubEntityLocalIndexSet<decltype(push_back(view_path,0)), ContainerIndex>;
//       typename SLIS::NodeStorage storage(_max_sub_entities);
//       for (std::size_t sub_entity = 0; sub_entity != storage.size(); ++sub_entity)
//         storage[sub_entity] = std::make_unique<LIS>(push_back(view_path,sub_entity), this->disjointCodimClosure());
//       return std::make_unique<SLIS>(std::move(storage));
//     }
//   }

//   template<class Ordering, Concept::MultiIndex Prefix, Concept::MultiIndex SubSpacePath>
//   auto makeLocalView(const std::shared_ptr<Ordering>& ordering,
//                      const Prefix& prefix, SubSpacePath) const
//   {
//     static_assert(SubSpacePath::size() <= Prefix::size(), "Sub space path cannot be larger than the total path from root");

//     constexpr std::size_t sub_space_depth = SubSpacePath::size();
//     constexpr std::size_t view_depth = Prefix::size() - sub_space_depth;
//     auto view_path = unpackIntegerSequence([&](auto... i){
//       return multiIndex(prefix[index_constant<sub_space_depth+i>{}] ...);
//     }, std::make_index_sequence<view_depth>{});

//     assert(&child(*ordering, prefix) == this &&
//            "This class should be a node of the root ordering");
//     // From the ordering, we extract the type of the container index for this
//     // node
//     using ContainerIndex = decltype(ordering->firstContainerIndex(prefix, SizeType{}, SizeType{}));
//     using FEM = typename Space::Traits::FiniteElementMap;
//     using EntitySet = typename Space::Traits::MergingStrategy::EntitySet;
//     constexpr std::size_t fem_dim = FEM::Traits::FiniteElement::Traits::LocalBasisType::Traits::dimDomain;
//     // and use it to instantiate the local ordering
//     if constexpr (fem_dim == EntitySet::dimension) {
//       return std::make_unique<LocalView<decltype(view_path), ContainerIndex>>(view_path, this->disjointCodimClosure());
//     } else {
//       using LV = LocalView<decltype(push_back(view_path,0)), ContainerIndex>;
//       using SLV = SubEntityLocalView<decltype(push_back(view_path,0)), ContainerIndex>;
//       typename SLV::NodeStorage storage(_max_sub_entities);
//       for (std::size_t sub_entity = 0; sub_entity != storage.size(); ++sub_entity)
//         storage[sub_entity] = std::make_unique<LV>(push_back(view_path,sub_entity), this->disjointCodimClosure());
//       return std::make_unique<SLV>(std::move(storage));
//     }
//   }

// private:
//   Space _space;
//   int _max_sub_entities = 0;
// };

// /**
//  * @brief Array implementation of an EntityOrderingNode
//  *
//  * @tparam MergingStrategy   A merging strategy between the node indices
//  * @tparam ChildOrdering     Child ordering type to store
//  * @tparam degree            Number of child orderings to keep
//  */
// template<class MergingStrategy,
//          Concept::TreeNode ChildOrdering,
//          std::size_t degree>
// class ArrayEntityOrdering
//   : public TypeTree::PowerNode<ChildOrdering, degree>
//   , public EntityOrderingNode<
//       ArrayEntityOrdering<MergingStrategy, ChildOrdering, degree>,
//       MergingStrategy>
// {
//   using TreeNode = TypeTree::PowerNode<ChildOrdering, degree>;
//   using OrderingNode = EntityOrderingNode<
//     ArrayEntityOrdering<MergingStrategy, ChildOrdering, degree>,
//     MergingStrategy>;

//   //! Array tree node of local orderings  @see Concepts::ArrayTreeNode
//   template<class ChildLocalNode>
//   struct LocalNode : public TypeTree::PowerNode<ChildLocalNode, degree>
//   {
//     LocalNode(typename TypeTree::PowerNode<ChildLocalNode,
//                                          degree>::NodeStorage&& storage)
//       : TypeTree::PowerNode<ChildLocalNode, degree>{ std::move(storage) }
//     {
//     }

//     void bindElement(const auto& entity) noexcept {
//       forEach(*this, [&](auto& child){ child.bindElement(entity); });
//     }
//   };

// public:
//   //! Constructs an array of entity orderings
//   ArrayEntityOrdering(typename TreeNode::NodeStorage&& storage,
//                       const MergingStrategy& merging_strategy)
//     : TreeNode{ std::move(storage) }
//     , OrderingNode{ merging_strategy }
//   {
//   }

//   template<class Ordering, Concept::MultiIndex Prefix, Concept::MultiIndex SubSpacePath>
//   auto makeLocalView(const std::shared_ptr<Ordering>& ordering,
//                          const Prefix& prefix, const SubSpacePath& sub_space_path) const
//   {
//     if constexpr (Prefix::size() < SubSpacePath::size()) {
//       auto child = sub_space_path[index_constant<Prefix::size()>{}];
//       return this->child(child).makeLocalView(ordering, push_back(prefix, child), sub_space_path);
//     } else {
//       using Child = std::decay_t<decltype(*this->child(0).makeLocalView(
//         ordering, push_back(prefix, 0), sub_space_path))>;
//       typename LocalNode<Child>::NodeStorage storage;
//       for (std::size_t i = 0; i < degree; ++i)
//         storage[i] =
//           this->child(i).makeLocalView(ordering, push_back(prefix, i), sub_space_path);
//       return std::make_unique<LocalNode<Child>>(std::move(storage));
//     }
//   }

//   //! Constructs an array of the local entity orderings from the entity
//   //! orderings
//   template<class Ordering, Concept::MultiIndex Prefix, Concept::MultiIndex SubSpacePath>
//   auto makeLocalIndexSet(const std::shared_ptr<Ordering>& ordering,
//                          const Prefix& prefix, const SubSpacePath& sub_space_path) const
//   {
//     if constexpr (Prefix::size() < SubSpacePath::size()) {
//       auto child = sub_space_path[index_constant<Prefix::size()>{}];
//       return this->child(child).makeLocalIndexSet(ordering, push_back(prefix, child), sub_space_path);
//     } else {
//       using Child = std::decay_t<decltype(*this->child(0).makeLocalIndexSet(
//         ordering, push_back(prefix, 0), sub_space_path))>;
//       typename LocalNode<Child>::NodeStorage storage;
//       for (std::size_t i = 0; i < degree; ++i)
//         storage[i] =
//           this->child(i).makeLocalIndexSet(ordering, push_back(prefix, i), sub_space_path);
//       return std::make_unique<LocalNode<Child>>(std::move(storage));
//     }
//   }

// private:
//   template<class Container>
//   using StaticSize = decltype(Container::size());

// public:
//   template<class Traits>
//   static constexpr auto makeVectorContainer()
//   {
//     using ChildContainer =
//       decltype(ChildOrdering::template makeVectorContainer<Traits>());
//     if constexpr (OrderingNode::containerBlocked()) {
//       return Traits::template makeArray<ChildContainer, degree>();
//     } else {
//       using ChildBlock =
//         typename Traits::template block_type<ChildContainer>::type;
//       if constexpr (Std::is_detected<StaticSize, ChildContainer>{})
//         return Traits::template makeArray<ChildBlock,
//                                           ChildContainer::size() * degree>();
//       else
//         return Traits::template makeVector<ChildBlock>();
//     }
//   }
// };

// template<class MergingStrategy, Concept::TreeNode ChildOrdering>
// class VectorEntityOrdering
//   : public TypeTree::DynamicPowerNode<ChildOrdering>
//   , public EntityOrderingNode<
//       VectorEntityOrdering<MergingStrategy, ChildOrdering>,
//       MergingStrategy>
// {
//   using TreeNode = TypeTree::DynamicPowerNode<ChildOrdering>;
//   using OrderingNode =
//     EntityOrderingNode<VectorEntityOrdering<MergingStrategy, ChildOrdering>,
//                        MergingStrategy>;

//   template<class ChildLocalNode>
//   struct LocalNode : public TypeTree::DynamicPowerNode<ChildLocalNode>
//   {
//     LocalNode(typename TypeTree::DynamicPowerNode<
//                   ChildLocalNode>::NodeStorage&& storage)
//       : TypeTree::DynamicPowerNode<ChildLocalNode>{ std::move(storage) }
//     {
//     }

//     void bindElement(const auto& entity) noexcept {
//       forEach(*this, [&](auto& child){ child.bindElement(entity); });
//     }
//   };

// public:
//   VectorEntityOrdering(typename TreeNode::NodeStorage&& storage,
//                        const MergingStrategy& merging_strategy)
//     : TreeNode{ std::move(storage) }
//     , OrderingNode{ merging_strategy }
//   {
//     for(std::size_t i = 0; i != this->degree(); ++i)
//       assert(this->childStorage(i));
//   }

//   template<class Ordering, Concept::MultiIndex Prefix, Concept::MultiIndex SubSpacePath>
//   auto makeLocalIndexSet(const std::shared_ptr<Ordering>& ordering,
//                          const Prefix& prefix, const SubSpacePath& sub_space_path) const
//   {
//     if constexpr (Prefix::size() < SubSpacePath::size()) {
//       auto child = sub_space_path[index_constant<Prefix::size()>{}];
//       assert(child < this->degree());
//       return this->child(child).makeLocalIndexSet(ordering, push_back(prefix, child), sub_space_path);
//     } else {
//       using Child = std::decay_t<decltype(*this->child(0).makeLocalIndexSet(
//         ordering, push_back(prefix, 0), sub_space_path))>;
//       typename LocalNode<Child>::NodeStorage storage(this->degree());
//       for (std::size_t i = 0; i < this->degree(); ++i)
//         storage[i] =
//           this->child(i).makeLocalIndexSet(ordering, push_back(prefix, i), sub_space_path);
//       return std::make_unique<LocalNode<Child>>(std::move(storage));
//     }
//   }

//   template<class Ordering, Concept::MultiIndex Prefix, Concept::MultiIndex SubSpacePath>
//   auto makeLocalView(const std::shared_ptr<Ordering>& ordering,
//                          const Prefix& prefix, const SubSpacePath& sub_space_path) const
//   {
//     if constexpr (Prefix::size() < SubSpacePath::size()) {
//       auto child = sub_space_path[index_constant<Prefix::size()>{}];
//       assert(child < this->degree());
//       return this->child(child).makeLocalView(ordering, push_back(prefix, child), sub_space_path);
//     } else {
//       using Child = std::decay_t<decltype(*this->child(0).makeLocalView(
//         ordering, push_back(prefix, 0), sub_space_path))>;
//       typename LocalNode<Child>::NodeStorage storage(this->degree());
//       for (std::size_t i = 0; i < this->degree(); ++i)
//         storage[i] =
//           this->child(i).makeLocalView(ordering, push_back(prefix, i), sub_space_path);
//       return std::make_unique<LocalNode<Child>>(std::move(storage));
//     }
//   }

//   template<class Traits>
//   static constexpr auto makeVectorContainer()
//   {
//     using ChildContainer =
//       decltype(ChildOrdering::template makeVectorContainer<Traits>());
//     if constexpr (OrderingNode::containerBlocked()) {
//       return Traits::template makeVector<ChildContainer>();
//     } else {
//       using ChildBlock =
//         typename Traits::template block_type<ChildContainer>::type;
//       return Traits::template makeVector<ChildBlock>();
//     }
//   }
// };

// template<class MergingStrategy, Concept::TreeNode... ChildOrdering>
// class TupleEntityOrdering
//   : public TypeTree::CompositeNode<ChildOrdering...>
//   , public EntityOrderingNode<
//       TupleEntityOrdering<MergingStrategy, ChildOrdering...>,
//       MergingStrategy>
// {
//   using TreeNode = TypeTree::CompositeNode<ChildOrdering...>;
//   using OrderingNode =
//     EntityOrderingNode<TupleEntityOrdering<MergingStrategy, ChildOrdering...>,
//                        MergingStrategy>;

//   template<class... ChildLocalNode>
//   struct LocalNode : public TypeTree::CompositeNode<ChildLocalNode...>
//   {
//     LocalNode(typename TypeTree::CompositeNode<
//                   ChildLocalNode...>::NodeStorage&& storage)
//       : TypeTree::CompositeNode<ChildLocalNode...>{ std::move(storage) }
//     {
//     }

//     void bindElement(const auto& entity) noexcept {
//       forEach(*this, [&](auto& child){ child.bindElement(entity); });
//     }
//   };

// public:
//   TupleEntityOrdering(typename TreeNode::NodeStorage&& storage,
//                       const MergingStrategy& merging_strategy)
//     : TreeNode{ std::move(storage) }
//     , OrderingNode{ merging_strategy }
//   {
//   }

//   template<class Ordering, Concept::MultiIndex Prefix, Concept::MultiIndex SubSpacePath>
//   auto makeLocalIndexSet(const std::shared_ptr<Ordering>& ordering,
//                          const Prefix& prefix, const SubSpacePath& sub_space_path) const
//   {
//     if constexpr (Prefix::size() < SubSpacePath::size()) {
//       auto child = sub_space_path[index_constant<Prefix::size()>{}];
//       return this->child(child).makeLocalIndexSet(ordering, push_back(prefix, child), sub_space_path);
//     } else {
//       auto unfold_children = [&](auto... i) {
//         using LSpace =
//           LocalNode<std::decay_t<decltype(*this->child(i).makeLocalIndexSet(
//             ordering, push_back(prefix, i), sub_space_path))>...>;
//         typename LSpace::NodeStorage storage{ this->child(i).makeLocalIndexSet(
//           ordering, push_back(prefix, i), sub_space_path)... };
//         return std::make_unique<LSpace>(std::move(storage));
//       };
//       auto indices = std::make_index_sequence<sizeof...(ChildOrdering)>{};
//       return unpackIntegerSequence(unfold_children, indices);
//     }
//   }

//   template<class Ordering, Concept::MultiIndex Prefix, Concept::MultiIndex SubSpacePath>
//   auto makeLocalView(const std::shared_ptr<Ordering>& ordering,
//                          const Prefix& prefix, const SubSpacePath& sub_space_path) const
//   {
//     if constexpr (Prefix::size() < SubSpacePath::size()) {
//       auto child = sub_space_path[index_constant<Prefix::size()>{}];
//       return this->child(child).makeLocalView(ordering, push_back(prefix, child), sub_space_path);
//     } else {
//       auto unfold_children = [&](auto... i) {
//         using LSpace =
//           LocalNode<std::decay_t<decltype(*this->child(i).makeLocalView(
//             ordering, push_back(prefix, i), sub_space_path))>...>;
//         typename LSpace::NodeStorage storage{ this->child(i).makeLocalView(
//           ordering, push_back(prefix, i), sub_space_path)... };
//         return std::make_unique<LSpace>(std::move(storage));
//       };
//       auto indices = std::make_index_sequence<sizeof...(ChildOrdering)>{};
//       return unpackIntegerSequence(unfold_children, indices);
//     }
//   }

// private:
//   template<class... C>
//   using StaticSizes = decltype((C::size() + ...));

//   template<class... T>
//   using HasCommonType = std::common_type_t<T...>;

// public:
//   template<class Traits>
//   static constexpr auto makeVectorContainer()
//   {
//     if constexpr (OrderingNode::containerBlocked()) {
//       return Traits::template makeTuple<
//         decltype(ChildOrdering::template makeVectorContainer<Traits>())...>();
//     } else {
//       using ChildContainers = std::tuple<
//         decltype(ChildOrdering::template makeVectorContainer<Traits>())...>;
//       return unpackIntegerSequence(
//         [](auto... i) {
//           static_assert(
//             Std::is_detected<
//               HasCommonType,
//               typename Traits::template block_type<
//                 std::tuple_element_t<i, ChildContainers>>::type...>{},
//             "Non-Blocked tuple children should yield a common container type");
//           using ChildBlock =
//             std::common_type_t<typename Traits::template block_type<
//               std::tuple_element_t<i, ChildContainers>>::type...>;
//           if constexpr (Std::is_detected<
//                           StaticSizes,
//                           std::tuple_element_t<i, ChildContainers>...>{}) {
//             constexpr std::size_t aggregated_size =
//               (std::tuple_element_t<i, ChildContainers>::size() + ...);
//             return Traits::template makeArray<ChildBlock, aggregated_size>();
//           } else
//             return Traits::template makeVector<ChildBlock>();
//         },
//         std::index_sequence_for<ChildOrdering...>{});
//     }
//   }
// };

// //! Returns a suitable Entity Ordering tree for a discrete-function-space tree
// template<Concept::Impl::SpaceTree Space>
// auto
// makeEntityOrdering(const Space& space)
// {
//   using MergingStrategy = typename Space::Traits::MergingStrategy;

//   static_assert(requires {typename MergingStrategy::EntitySet;},
//     "Merging strategy for this node shall provide an entity set. "
//     "Apply the following rules to avoid this error:"
//     " * Leaf nodes usually need an entity grouping."
//     " * If a node is grouped by entity, all of its children have to be grouped by entity."
//   );

//   if constexpr (Concept::LeafTreeNode<Space>) {
//     using EntityOrdering = LeafEntityOrdering<Space>;
//     return std::make_unique<EntityOrdering>(space);
//   } else if constexpr (Concept::ArrayTreeNode<Space>) {
//     constexpr std::size_t degree = Space::degree();
//     using Child = std::decay_t<decltype(*makeEntityOrdering(space.child(0)))>;
//     using EntityOrdering = ArrayEntityOrdering<MergingStrategy, Child, degree>;
//     typename EntityOrdering::NodeStorage storage;
//     for (std::size_t i = 0; i < degree; ++i)
//       storage[i] = makeEntityOrdering(space.child(i));
//     return std::make_unique<EntityOrdering>(std::move(storage), space.mergingStrategy());
//   } else if constexpr (Concept::VectorTreeNode<Space>) {
//     std::size_t degree = space.degree();
//     using Child = std::decay_t<decltype(*makeEntityOrdering(space.child(0)))>;
//     using EntityOrdering = VectorEntityOrdering<MergingStrategy, Child>;
//     typename EntityOrdering::NodeStorage storage(degree);
//     for (std::size_t i = 0; i < degree; ++i)
//       storage[i] = makeEntityOrdering(space.child(i));
//     return std::make_unique<EntityOrdering>(std::move(storage), space.mergingStrategy());
//   } else {
//     static_assert(Concept::TupleTreeNode<Space>);
//     auto unfold_children = [&](auto... i) {
//       using EntityOrdering = TupleEntityOrdering<
//         MergingStrategy,
//         std::decay_t<decltype(*makeEntityOrdering(space.child(i)))>...>;
//       typename EntityOrdering::NodeStorage storage{ makeEntityOrdering(
//         space.child(i))... };
//       return std::make_unique<EntityOrdering>(std::move(storage), space.mergingStrategy());
//     };
//     auto indices = std::make_index_sequence<Space::degree()>{};
//     return unpackIntegerSequence(unfold_children, indices);
//   }
// }

// } // namespace Dune::Assembler::Impl

#endif // DUNE_PDELAB_BASIS_ORDERING_ENTITY_HH
